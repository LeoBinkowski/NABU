		.Z80
		.RADIX 10
Z80		EQU 0FFH
;
		CSEG
;
		INCLUDE LINKTAB.EXA
		INCLUDE COMMON.MRO
		INCLUDE	CLKAT.MRO
		INCLUDE QSPEQU.EQU
		INCLUDE VARIABLE.EXA
		EXTRN FLIP,QSPRITES,QUERY,DECFM,LEVELSC,GAMEOPT,DOSOUND
		EXTRN QPAT,LEVCOL,MISCGRA,TDISKS,CREST,SETDISK,ZIPTHRU,PLAYER
		EXTRN P1DEMO,P2DEMO,WAIT1S,SATABLE,ADDSCORE,SOUND2
		EXTRN A_OFF,B_OFF,C_OFF,CHANLS
		EXTRN LEV1H,LEV1H2,LEV2H,LEV2H2,LEV1H3,LEV3H,LEV3H2,LEV3H3
		EXTRN LEV4H,LEV4H2,LEV4H3,CJSO1,CJSO2
		EXTRN DASO1,GBSO1,QFSO1,QFSO2,UWSO1,UWSO2,BHSO1,BHSO2
		EXTRN QJSO1,QJSO2,SSSO1,SSSO2,CBSO1,CBSO2,CFSO1,CFSO2
;
UP 	EQU 08H
DOWN 	EQU 02H
LEFT 	EQU 01H
RITE 	EQU 04H
;
;***THIS IS A TABLE OF INITIAL DELAYS FOR WHEN UGH AND WRONGWAY APPEAR
;
UWTABLE:: DB	50,50,3,50,3,3,50,6,50,3,20,6,50,50,50,10,50,50
	  DB	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
;
TIMINIT::
	CALL REMOVEALL			;MAKE SURE ALL MY TASKS ARE REMOVED
	CALL MOVEOUT			;THIS WILL MOVE THE SPRITES OFF THESCREEN
	LD A,(LEVEL)		;GET THE CURRENT LEVEL
	DEC A			;SUBTRACT 1 FROM THE LEVEL
	SLA A
	SLA A			;MULTIPLY BY 4
	LD C,A			;MOVE RESULT TO C
	LD A,(ROUND)		;GET THE CURRENT ROUND
	ADD A,C			;ADD THE TWO
	LD (LEVROU),A		;SAVE THE RESULT WHICH IS THE NUMBER OF 
				;SCREENS SEEN
	CP 35			;IS IT GREATER THAN 35
	JP C,INIPL3		;DON'T FIX THE PLAYER DEMO VARIABLE
	LD A,(PLAYER)		;WHICH PLAYER IS IT
	AND A			;IS IT 0
	JR NZ,INIPL2		;IF NOT GO FIX PLAYER 2
	LD A,8
	LD (P1DEMO),A		;SET DEMO LEVEL TO 8
	JR INIPL3		;JUMP AROUND FIXING PLAYER 2 THE SAME WAY
INIPL2:
	LD A,8
	LD (P2DEMO),A		;RESET PLAYER 2 DEMO LEVEL TO 8
INIPL3:
	LD A,00H
	LD (OLDVAL),A
	LD (FLACOL),A		;RESET FLASH COLOR VALUE TO 0
	LD (FRECOUNT),A
	LD (UNITIME),A		;RESET THE UNIVERSAL TIME CLOCK
	LD IX,UGH		;GET FIRST ADDRESS OF CHARACTER CONTROL AREA
	LD (IX),A		;RESET THE MOVE BYTES OF EACH
	LD (IX+8),A
	LD (IX+9),A
	LD (IX+17),A
	LD (IX+18),A
	LD (IX+26),A
	LD (IX+27),A
	LD (IX+35),A
	LD (IX+36),A
	LD (IX+44),A
	LD (IX+45),A
	LD (IX+53),A
	LD (IX+54),A
	LD (IX+62),A
	LD (IX+63),A
	LD (IX+71),A
	LD (IX+72),A
	LD (IX+80),A
	LD (IX+81),A
	LD IX,QCONTROL		;GET QBERTZS CONTROL ADDRESS
	LD (IX),80H		;SET MOVE BYTE TO MEAN ACTIVE BUT NOT MOVING
	LD A,(PLAYER)		;GET THE CURRENT PLAYER
	AND A
	JP NZ,INCP2		;IF NOT GO FIX PLAYER 2 COORDINATES
	LD A,(P1XC)
	LD (IX+5),A		;SET CURRENT X TO LAST 
	LD (CURX),A
	LD A,(P1YC)
	LD (IX+6),A
	LD (CURY),A		;SET CURRENT Y TO LAST 
	JR INCP3
INCP2:
	LD A,(P2XC)
	LD (IX+5),A
	LD (CURX),A
	LD A,(P2YC)
	LD (IX+6),A
	LD (CURY),A
INCP3:
	LD (IX+8),00H		;RESET JUMP SHIFT VARIABLE
	PCALL SPMOVE,QBSPRITE,(CURY),(CURX)	
	PCALL SPMOVE,QBEYES,(CURY),(CURX)
	LD HL,UWTABLE		;GET BASE ADDRESS OF INITIAL DELAY COUNTS
	LD A,(LEVROU)		;GET CURRENT LEVEL/ROUND VARIABLE
	DEC A			;DECREMENT 1 BECAUSE DELAY 1 IS OFFSET 0
	LD C,A			;MOVE RESULT TO C
	LD B,0			;CLEAR B
	ADD HL,BC		;ADD BASE ADDRESS AND OFFSET
	LD A,(HL)
	LD (GR3DEL),A		;SAVE THE DELAY
	LD A,3	
	LD (GR1DEL),A
	LD A,17
	LD (GR2DEL),A		;INITIALIZE THE INITIAL DELAY FOR EACH GROUP
				;IN THE CHARACTER SELECTION ROUTINE.
		SETSK	DOSOUND,TASKSND,1,1
		SETSK	MOVQBERT,TASK1,01H,01H
		SETSK	UNIHANDLER,TASK27,1,1
		SETSK	M_QBERT,TASK2,01H,01H
UNFREEZE:
		SETSK	UNICLOCK,TASK21,50H,01H
		SETSK	MRED1,TASK3,10H,1
		SETSK	MRED2,TASK4,12H,01H
		SETSK	MGBALL,TASK7,15,01H
		SETSK	MPBALL,TASK8,14H,1
		SETSK	MUGH,TASK11,40H,01H
		SETSK	MWRONG,TASK14,40H,01H
		SETSK	MSAM,TASK15,10H,01H
		SETSK	MSLICK,TASK16,10H,01H
		SETSK	MCOILY,TASK19,10H,01H
;UNFREEZE:
		SETSK	M2MRED1,TASK5,1,01H
		SETSK	M2MRE2,TASK6,1,01H
		SETSK	M2MRE3,TASK9,1,01H
		SETSK	M2MRE4,TASK10,1,01H
		SETSK	M2MRE5,TASK12,1,01H
		SETSK	M2MRE6,TASK13,1,01H
		SETSK	M2MRE7,TASK17,1,01H
		SETSK	M2MRE8,TASK18,1,01H
		SETSK	M2MRE9,TASK20,1,01H
		SETSK	COLLISION,TASK25,1,1
		RET
;***THIS SECTION INITIALIZES THE SPRITE NAMES AND ATTRIBUTES
TIMGRAPH::
	PCALL VRAMLD,0D5H*8,QSPRITES,1800H	;LOAD SPRITE PATTERNS
MOVEOUT::	;CALLING THIS LABEL WILL MOVE ALL THE SPRITES OFF THE SCREEN
	PCALL	VRAMLD,128,SATABLE,3F00H	;TRY SET SPRITE ATT TABLE THIS
						;WAY TO SAVE SPACE. THE TABLE
						;SETS THE VERTICAL POSITION
						;TO 0E0H GOOD TO MOVE OFF SCRE.
;	PCALL SPMOVE,QBEYES,22,120
;	PCALL SPMOVE,QBSPRITE,22,120
	RET
;***END OF GRAPHICS INITIALIZATION
;
;***THIS ROUTINE REMOVES ALL MY TASKS
REMOVEALL::
	N.CLKRV 0
	PCALL SOUND2,A_OFF
	PCALL SOUND2,B_OFF
	PCALL SOUND2,C_OFF	;TURN OFF AL THE SOUNDS IF ALL TASKS REMOVED
FREEZE:
				;IF THIS IS CALLED ONLY THE CHARACTER MOVING
				;ROUTINES ARE REMOVED. THIS IS CALLED WHEN
				;QBERT CATCHES THE GREEN BALL 
	N.CLKRV TASK3		;MRED1
	N.CLKRV TASK4		;MRED2
	N.CLKRV TASK7		;MGBALL
	N.CLKRV TASK8		;MPBALL
	N.CLKRV TASK11		;MUGH
	N.CLKRV TASK14		;MWRONG
	N.CLKRV TASK15		;MSAM
	N.CLKRV TASK16		;MSLICK
	N.CLKRV TASK19		;MCOILY
	N.CLKRV TASK21		;UNICLOCK
	N.CLKRV TASK25		;COLLISION TASK. CAN'T DIE WHEN FREEZE ACTIVE 
	N.CLKRV TASK5		;M2MRED1
	N.CLKRV TASK6		;M2MRE2
	N.CLKRV TASK9		;M2MRE3
	N.CLKRV TASK10		;M2MRE4
	N.CLKRV TASK12		;M2MRE5
	N.CLKRV TASK13		;M2MRE6
	N.CLKRV TASK17		;M2MRE7
	N.CLKRV TASK18		;M2MRE8
	N.CLKRV TASK20		;M2MRE9
	RET
;***END OF ROUTINE TO REMOVE ALL THE TASKS
;
;*** THIS ROUTINE WILL HANDLE SETTING THE INTERVAL AND RULES FOR WHEN CHARACTER
;	COME OUT.
UNIHANDLER::
	LD A,(LASTTICK)		;GET LAST VALUE READ BY THIS ROUTINE
	LD C,A
	LD A,(UNITIME)		;GET CURRENT CLOCK VALUE
	CP C			;ARE THEY EQUAL ?
	RET Z			;IF SO RETURN. MUST WAIT FOR NEXT TICK
	LD (LASTTICK),A		;SAVE NEW CLOCK VALUE
	XOR A
	LD (UNISTOP),A		;IF THIS FLAG SET IT MEANS THAT THE DELAY COUNT
				;SHOULD BE DECREMENTED BUT NO CHARACTER SHOULD
				;BE ACTIVATED FROM THAT GROUP.
HGROU1:				;THIS HANDLES THE CHARACTERS RBALL1,2 + PBALL
	LD A,(GR1DEL)		;GET THE INITIAL DELAY FOR GROUP 1
	AND A			;HAS IT BEEN DECREMENTED TO 0
	JR Z,CGR1		;IF SO GO SELECT WHICH CHARACTER TO ACTIVATE
	DEC A			;ELSE DRECREMENT THE INITIAL DELAY VARIABLE
	LD (GR1DEL),A		;SAVE RESULT
	JP HGROU2		;GO CHECK SECOND GROUP
CGR1:
	LD A,(RBALL1)		;CHECK STATUS OF RED BALL NUMBER 1
	CP 7FH			;IS HE ACTIVE
	JR NC,CGR11		;IF SO GO CHECK RED BALL 2
	LD IX,RBALL1		;SET IX TO POINT TO RBALL1 CONTROL MATRIX
	CALL M1MRED1		;CALL ROUTINE TO INITIALIZE RED BALL 1 MOVEMENT
	LD A,1
	LD (UNISTOP),A		;SET FLAG TO MEAN WE HAVE ACTIVATED 1 CHARACTER
	JR HGROU2		;GO CHECK SECOND GROUP
CGR11:
	LD A,(RBALL2)		;CHECK STATUS OF RED BALL NUMBER 2
	CP 7FH			;IS HE ACTIVE
	JR NC,CGR12		;IF SO GO CHECK PURPLE BALL
	LD IX,RBALL2	
	CALL M1MRE2		;CALL ROUTINE TO START RED BALL 2 MOVING
	LD A,1
	LD (UNISTOP),A		;SET FLAG TO MEAN 1 CHARACTER ALREADY STARTED
	JR HGROU2		;GO CHECK SECOND GROUP
CGR12:
	LD A,(PBALL)		;CHECK STATUS OF RED BALL NUMBER 2
	CP 7FH			;IS HE ACTIVE
	JR NC,CGR13		;IF SO GO CHECK PURPLE BALL
	LD IX,PBALL	
	CALL MPB2		;CALL ROUTINE TO START RED BALL 2 MOVING
CGR13:
;**********************************************************************
;
HGROU2:				;THIS HANDLES THE CHARACTERS GBALL,SAM,SLICK
	LD A,(GR2DEL)		;GET THE INITIAL DELAY VARIABLE FOR GROUP 2
	AND A			;IS IT 0
	JR Z,CGR2		;IF SO GO HANDLE WHICH CHARACTER TO ACTIVATE
	DEC A			;ELSE DECREMENT INITIAL DELAY COUNT
	LD (GR2DEL),A		;SAVE NEW VALUE
	JP HGROU3		;GO CHECK THIRD GROUP
CGR2:
	LD A,(UNISTOP)		;GET FLAG THAT TELLS IF CHARACTER ALREADY START
	CP 1			;IS FLAG TRUE
	JR Z,HGROU3		;IF SO GO HANDLE THIRD GROUP
	LD A,(LEVROU)		;GET THE LEVEL ROUND INDICATOR
	CP 4			;IS IT THE FOURTH SCREEN
	JP C,CGR215		;IF NOT GO SELECT GREEN BALL. SAM AND SLICK 
				;DON'T APPEAR BEFORE SCREEN 4
	LD A,(NEXTGREEN)	;GET FLAG WHICH TELLS WHICH GREEN TO SELECT
	CP 1
	JR Z,CGR21		;IF 1 GO TRY START SAM
	CP 2		
	JR Z,CGR22		;IF 2 GO TRY START SLICK
				;OTHERWISE TRY START GREEN BALL
CGR215:
	LD A,(GBALL)		;GET STATUS BYTE OF GREEN BALL
	CP 7FH			;IS IT ACTIVE
	JR NC,HGROU3		;IF SO GO CHECK NEXT GROUP
	LD IX,GBALL		;IX GETS THE ADDRESS OF GREEN BALL MATRIX
	CALL MGB2		;CALL ROUTINE TO ACTIVATE THE GREEN BALL
	LD A,17
	LD (GR2DEL),A		;RESET DELAY TO 17 BEATS BEFORE SELECTING
				;ANOTHER FROM THIS GROUP
	LD A,1
	LD (NEXTGREEN),A	;SET NEXT GREEN TO BE ACTIVATED TO BE SAM
	JP HGROU3		;GO CHECK THIRD GROUP

CGR21:
	LD A,(SAM)		;GET STATUS OF SAM
	CP 7FH			;IS HE ACTIVE
	JR NC,HGROU3		;IF SO GO CHECK THIRD GROUP
	LD IX,SAM		;IX GETS THE ADDRESS OF SAM CONTROL MATRIX
	CALL MSA2		;CALL ROUTINE TO ACTIVATE SAM
	LD A,17
	LD (GR2DEL),A		;RESET DELAY BETWEEN GREEN CHARACTERS
	LD A,2
	LD (NEXTGREEN),A	;SET NEXT GREEN CHARACTER TO BE SLICK
	JP HGROU3		;GO CHECK THIRD GROUP

CGR22:
	LD A,(SLICK)		;GET STATUS OF SLICK
	CP 7FH			;IS HE ACTIVE
	JR NC,HGROU3		;IF SO GO CHECK GROUP3
	LD IX,SLICK		;IX GETS SLICKS CONTROL MATRIX ADDRESS
	CALL MSL2		;CALL ROUTINE TO ACTIVATE SLICK
	LD A,17
	LD (GR2DEL),A		;RESET DELAY BETWEEN GREEN CHARACTERS
	XOR A
	LD (NEXTGREEN),A	;SET NEXT GREEN CHARACTER TO BE GREEN BALL
;
;
HGROU3:
	LD A,(GR3DEL)		;THIS HANDLES THE CHARACTERS UGH,WRONG-WAY
	AND A			;IS THE INITIAL DELAY 0
	JR Z,CGR3		;IF SO GO HANDLE WHICH CHARACTER TO ACTIVATE
	DEC A			;ELSE DECREMENT INITIAL DELAY VALUE
	LD (GR3DEL),A		;SAVE NEW VALUE
	RET			;RETURN BECAUSE THERE ARE NO MORE GROUPS.
CGR3:
	PCALL SOUND2,UWSO1	;DO SOUND FOR WHEN UGH AND WRONG WAY START
	PCALL SOUND2,UWSO2
	PCALL SOUND2,C_OFF
	LD A,(NEXTPURPLE)	;SEE WHICH OF UGH AND WRONG WE SHOULD CHECK
	AND A
	JR NZ,CGR32		;IF NOT ZERO GO CHECK WRONG WAY
				;ELSE IT MUST BE UGH
	LD A,(UGH)		;GET UGHS CURRNET STATUS
	CP 7FH			;IS HE MOVING
	RET NC			;IF SO RETURN
	LD IX,UGH		;IX GETS UGHS CONTROL MATRIX ADDRESS
	CALL MUGH2		;CALL ROUTINE TO ACTIVATE UGH
	LD A,1
	LD (NEXTPURPLE),A	;SET NEXT CHARACTER TO CHECK TO BE WRONG
	LD A,3
	LD (GR3DEL),A		;SET A DELAY OF 3 TICKS TILL NEXT CHECK
	RET
CGR32:
	LD A,(WRONG)		;GET WRONG CURRNET STATUS
	CP 7FH			;IS HE MOVING
	RET NC			;IF SO RETURN
	LD IX,WRONG		;IX GETS WRONG CONTROL MATRIX ADDRESS
	CALL MWR2		;CALL ROUTINE TO ACTIVATE UGH
	XOR A
	LD (NEXTPURPLE),A	;SET NEXT CHARACTER TO CHECK TO BE UGH
	LD A,3
	LD (GR3DEL),A		;SET A DELAY OF 3 TICKS TILL NEXT CHECK
	RET
;
;***END OF ROUTINE WHICH HANDLES TIMING AND SELECTION OF CHARACTERS FOR 
;	MOVEMENT.
;
;***THIS ROUTINE WILL HANDLE ALL INVOLVED IN PUTTING UP AND DOING
;	THE LEVEL DEMO
DODEMO::
	CALL TIMGRAPH
	CALL MOVEOUT
	LD A,01
	LD (INDEMO),A
	XOR A
	LD (DEMODONE),A		;SET DEMO FINISHED FLAG TO FALSE.
	LD A,(PLAYER)
	CP 0			;IS THIS PLAYER 1
	JR NZ,DOD2		;IF NOT ITS PLAYER 2
	LD A,(LEVEL)		;GET THE LEVEL
	LD (P1DEMO),A		;SET THE LEVEL OF DEMO FOR PLAYER 1 TO THIS L
	JR DOD3
DOD2:
	LD A,(LEVEL)		;GET LEVEL
	LD (P2DEMO),A		;SET PLAYER 2 DEMO LEVEL TO THIS LEVEL
DOD3:
	LD HL,LDEMO		;GET THE DEMO TABLE ADDRESS
	LD (DPTR),HL		;PUT THEM IN THE DATA POINTER VARIABLE
	PCALL	VRAMLD,300H,LEVELSC,3C00H
	PCALL	VRAMLD,1CH*8,LEVCOL,2800H+80H*8
	PCALL	VRAMLD,1CH*8,LEVCOL,3000H+80H*8
	PCALL	RPATRN,QPAT
	PCALL LPATRN,QPAT,800H
	PCALL LPATRN,QPAT,1000H
	LD A,(LEVEL)
	DEC A
	SLA A
	SLA A		;(ROUND-1)*4+OFFSET TO GET SPRITE NUMBER 'NUMBER'
	LD C,A		;MOVE TO C
	LD A,84H	;BASE ADDRESS OF NUUMBERS
	ADD A,C
	LD (TEST),A
	PCALL SPNAME,LNUMBER,(TEST)
	PCALL SPMOVE,LNUMBER,168,120
	PCALL SPMOVE,DEMBL1,71,96	;MOVE THE BLANKING SPRITE TO RIGHT SPOT
	PCALL SPMOVE,DEMBL2,71,144
	PCALL SPMOVE,DEMBL3,87,112
	PCALL SPMOVE,DEMBL4,87,128
	CALL VBLKOFF
	LD IX,QCONTROL
	LD (IX),80H
	LD A,120
	LD (IX+3),A
	LD (IX+1),A
	LD (IX+5),A
	LD A,22
	LD (IX+4),A
	LD (IX+2),A
	LD (IX+6),A
	LD (IX+8),0
	PCALL AUDIOWR,7,0F8H
	N.CLKRV TASKSND
	SETSK DOSOUND,TASKSND,1,1
	LD A,(LEVEL)
	CP 2
	JR Z,TU2
	CP 6
	JR Z,TU2
	CP 3
	JR Z,TU3
	CP 7
	JR Z,TU3
	CP 4
	JR Z,TU4
	CP 8
	JR Z,TU4 
	PCALL SOUND2,LEV1H	;IF REACHED HERE LEVEL IS 1,5, OR 9
	PCALL SOUND2,LEV1H2
	PCALL SOUND2,LEV1H3
	JP ETUNE
TU2:
	PCALL SOUND2,LEV2H	;IF REACHED HERE LEVEL IS 2,6
	PCALL SOUND2,LEV2H2
	PCALL SOUND2,C_OFF
	JP ETUNE
TU3:
	PCALL SOUND2,LEV3H	;IF REACHED HERE LEVEL IS 3,7
	PCALL SOUND2,LEV3H2
	PCALL SOUND2,LEV3H3
	JP ETUNE
TU4:
	PCALL SOUND2,LEV4H	;IF REACHED HERE LEVEL IS 4,8
	PCALL SOUND2,LEV4H2
	PCALL SOUND2,LEV4H3
;
ETUNE:
	LD A,(CHANLS)
	AND A
	JR NZ,ETUNE		;IF 1 OR MORE CHANELS ON TUNE IS NOT OVER
	SETSK MOVQBERT,TASK1,01H,01H
	SETSK M_QBERT,TASK2,01H,01H
DCONT::
	LD A,(DEMODONE)			;GET CONTENTS OF DEMO FINISHED FLAG
	CP 1
	JP Z,DEMFIN			;IF FLAG IS SET JUMP TO DEMO FINISHED
	JR DCONT
DEMFIN:
	N.CLKRV TASK1
	N.CLKRV TASK2		;REMOVE TASK THAT MOVES QBERT IN DEMO
DEMF2:
	LD A,(CHANLS)
	AND A
	JR NZ,DEMF2		;LOOP HERE UNTIL SOUNDS ARE OFF
	CALL WAIT1S
	CALL VBLKON
	PCALL RPATRN,MISCGRA
	PCALL LPATRN,MISCGRA,800H
	PCALL LPATRN,MISCGRA,1000H
	CALL SETDISK
	LD A,(ROUND)
	DEC A
	LD (ROUND),A
	RET
;***END OF ROUTINE TO DO THE LEVEL DEMO
;
;***THIS ROUTINE WILL COUNT THE TIME THAT THINGS HAVE BEEN FROZEN BY GETTIN
;	THE GREEN BALL. IT WILL ALSO RESTART THE MOVEMENT ROUTINES
FREDELAY:
	LD A,(FLACOL)		;GET THE CURRENT COLOR TO FLASH BYTE
	CPL
	LD (FLACOL),A		;SAVE NEW ONE
	AND A
	JP Z,FRBLACK		;IF ZERO SET BACKGROUND TO BLACK
	SETCOLR MAGENTA,MAGENTA
	JP INCFRE
FRBLACK:
	SETCOLR BLACK,BLACK
INCFRE:
	LD A,(FRECOUNT)		;GET COUNT FOR TIMES ROUTINE CALLED
	INC A			;ADD 1
	LD (FRECOUNT),A		;SAVE NEW RESULT
	CP 10			;EXECUTED TENTIMES?
	RET C			;IF LESS THAN TEN TIMES RETURN
	LD A,0
	LD (FRECOUNT),A		;RESET THE COUNT VARIABLE
	SETCOLR BLACK,BLACK	;FIX THE BACKGROUND COLOR
	N.CLKRV TASK26		;REMOVE THIS TASK
	CALL UNFREEZE		;RESTART ALL MOVEMENT
	RET
;***END OF FREEZE DELAY ROUTINE
;
;***THIS SECTION HANDLES THE COLLISION TESTINGWITH THE DIFFERENT RULES
;	FOR EACH CHARACTER.
COLLISION:
	LD IY,QCONTROL		;IY GETS QBERTS CONTROL MATRIX
	LD A,(IY)		;GET QBERTS MOVE BYTE
	CP 00H			;IS HE ON A DISK
	RET Z
	LD IX,RBALL1		;IX GETS ADDRESS OF RED BALL #1
	LD A,(IX)		;GET RED BALL MOVE BYTE
	CP 80H			;IS IT ACTIVE
	JP C,CRB3		;IF NOT MOVING GO CHECK THE NEXT ONE
	LD A,(IY)		;GET QBERTS MOVE BYTE
	CP 81H			;MOVING
	JP C,CRB2		;IF QBERT NOT MOVING TWO PLANE TEST
	CALL SOURDEST		;IF NOT IS SOURCE EQUAL TO DESTINATION
	CP 00H			;IS SOURCE = DESTINATION
	JP Z,CRB2		;IF EQUAL DO TWO PLANE COLLISION
	CALL DESTDEST		;CALL ROUTINE TO CHECK IF BOTH HAVE SAME DEST
	CP 00H			;WAS RESULT POSITIVE
	JP Z,CRB2		;IF TRUE GO DO TWO PLANE CHECK
	JP CRB3			;GO CHECK RED BALL
CRB2:
	CALL TWOPLANE		;GO DO TWO PLANE COLLISION TEST
	CP 00H			;WAS COLLISION TEST VALID
	JP Z,COLLDEAD		;IF TRUE GO KILL QBERT
CRB3:
	LD IX,RBALL2		;IX GETS ADDRESS OF RED BALL #1
	LD A,(IX)		;GET RED BALL MOVE BYTE
	CP 80H			;IS IT ACTIVE
	JP C,CRB5		;IF NOT MOVING GO CHECK THE NEXT ONE
	LD A,(IY)		;GET QBERTS MOVE BYTE
	CP 81H			;MOVING
	JP C,CRB4		;IF QBERT NOT MOVING TWO PLANE TEST
	CALL SOURDEST		;IF NOT IS SOURCE EQUAL TO DESTINATION
	CP 00H			;IS SOURCE = DESTINATION
	JP Z,CRB4		;IF EQUAL CHECK TWO PLANE COLLISION
	CALL DESTDEST		;IS DESTINATION = DESTINATION
	CP 00			;WAS RESULT POSITIVE
	JP Z,CRB4		;IF EQUAL GO CHECK TWO PLANE COLLISION
	JP CRB5			;GO CHECK NEXT
CRB4:
	CALL TWOPLANE		;GO DO TWO PLANE COLLISION TEST
	CP 00H			;WAS COLLISION TEST VALID
	JP Z,COLLDEAD		;IF TRUE GO KILL QBERT
CRB5:
	LD IX,UGH		;GET UGHS CONTROL MATRIX INTO IX
	LD A,(IX)		;GET THE MOVE BYTE
	CP 80H			;IS HE WAITING ON A SURFACE?
	JP NZ,CRB6		;IF NOT GO CHECK NEXT CHARACTER
	LD IY,QCONTROL		;GET ADDRESS OF QBERT CONTROL MATRIX IN IY
	CALL TWOPLANE		;GO CHECK FOR 2 PLANE COLLISION
	CP 00H			;WAS COLLISION TEST VALID
	JP Z,COLLDEAD		;IF SO GO KILL QBERT
CRB6:
	LD IX,WRONG		;GET WRONG WAYS CONTROL MATRIX INTO IX
	LD A,(IX)		;GET THE MOVE BYTE
	CP 80H			;IS HE WAITING ON A SURFACE?
	JP NZ,CRB7		;IF NOT GO CHECK NEXT CHARACTER
	LD IY,QCONTROL		;GET ADDRESS OF QBERT CONTROL MATRIX IN IY
	CALL TWOPLANE		;GO CHECK FOR 2 PLANE COLLISION
	CP 00H			;WAS COLLISION TEST VALID
	JP Z,COLLDEAD		;IF SO GO KILL QBERT
CRB7:
	LD IX,SAM		;IX GETS SAMS CONTROL MATRIX
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS SAM ACTIVE?
	JP C,CRB8		;IF NOT GO CHECK NEXT
	LD IY,QCONTROL		;PASS QBERT CONTROL MATRIX IN IY
	CALL TWOPLANE		;TEST TWO PLANE COLLISION
	CP 00H			;WAS RESULT TRUE
	JP NZ,CRB8		;IF NOT GO CHECK NEXT CHARACTER
	LD (IX),00		;SET SAM MOVE BYTE TO MEAN INACTIVE
	LD (IX+8),00H		;RESET THE JUMP COUNT TO 0
	PCALL SPMOVE,SASPRITE,0E0H,00H	;MOVE THE SPRITE OUT OF THE WAY
	PCALL ADDSCORE,200H
CRB8:
	LD IX,SLICK		;IX GETS SLICK CONTROL MATRIX
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS SLICK ACTIVE?
	JP C,CRB9		;IF NOT GO CHECK NEXT
	LD IY,QCONTROL		;PASS QBERT CONTROL MATRIX IN IY
	CALL TWOPLANE		;TEST TWO PLANE COLLISION
	CP 00H			;WAS RESULT TRUE
	JP NZ,CRB9		;IF NOT GO CHECK NEXT CHARACTER
	LD (IX),00		;SET SLICK MOVE BYTE TO MEAN INACTIVE
	LD (IX+8),00H		;RESET THE JUMP COUNT TO 0
	PCALL SPMOVE,SLSPRITE,0E0H,00H	;MOVE THE SPRITE OUT OF THE WAY
	PCALL SPMOVE,SLGLASS,0E0H,00H	;MOVE SLICKS GLASSES TOO
	PCALL ADDSCORE,200H
CRB9:
	LD IX,GBALL		;IX GETS THE GREEN BALL ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;SEE IF IT IS ACTIVE
	JP C,CRB10		;IF NOT GO CHECK NEXT CHARACTER
	LD IY,QCONTROL		;IY GETS QBERT CONTROL MATRIX
	CALL TWOPLANE		;GO CHECK TWO PLANE COLLISION
	CP 00H			;WAS RESULT POSITIVE
	JP NZ,CRB10		;IF NOT GO CHECK NEXT CHARACTER
	PCALL SOUND2,GBSO1	;START FREEZE SOUND
	PCALL SOUND2,B_OFF
	PCALL SOUND2,C_OFF
	CALL FREEZE		;CALL ROUTINE TO FREEZE ALL OBJECTS
	LD (IX),0		;TELL GREEN BALL NOT TO MOVE
	LD (IX+8),0		;RESET JUMP COUNT VARIABLE
	PCALL SPMOVE,GBSPRITE,0E0H,00H	;MOVE BALL SPRITE AWAY
	PCALL ADDSCORE,100H
	SETSK FREDELAY,TASK26,30,1	;EXECUT DELAY ROUTINE EVERY 1/2 SECOND
CRB10:
	LD IX,COILY		;IX GETS ADDRESS OF COILY CONTROL MATRIX
	LD A,(IX)		;GET COILYMOVE BYTE
	CP 80H			;IS IT ACTIVE
	JP C,CRB12		;IF NOT MOVING GO CHECK THE NEXT ONE
	LD A,(IY)		;GET QBERTS MOVE BYTE
	CP 81H			;MOVING
	JP C,CRB11		;IF QBERT NOT MOVING TWO PLANE TEST
	CALL SOURDEST		;IF NOT IS SOURCE EQUAL TO DESTINATION
	CP 00H			;IS SOURCE = DESTINATION
	JP Z,CRB11		;IF EQUAL DO TWO PLANE COLLISION
	CALL DESTDEST		;CALL ROUTINE TO CHECK IF BOTH HAVE SAME DEST
	CP 00H			;WAS RESULT POSITIVE
	JP Z,CRB11		;IF TRUE GO DO TWO PLANE CHECK
	JP CRB12		;GO CHECK NEXT CHARACTER
CRB11:
	CALL TWOPLANE		;GO DO TWO PLANE COLLISION TEST
	CP 00H			;WAS COLLISION TEST VALID
	JP NZ,CRB12		;IF COLLISION WAS FALSE GO CHECK NEXT CHARACTER
	PCALL SPMOVE,CTSPRITE,0E0H,00H
	PCALL SPMOVE,CBSPRITE,0E0H,00H
	LD A,1			;GET MASK FOR NOISE
	LD (POPFLG##),A		;PUT IT IN THE FLAG
	PCALL SOUND2,CCQSO1##	;
	PCALL SOUND2,CCQSO2##	;
	PCALL SOUND2,A_OFF	;
	JP COLLD1    		;IF TRUE GO KILL QBERT
CRB12:
	LD IX,PBALL		;IX GETS ADDRESS OF PURPLE BALL 
	LD A,(IX)		;GET PURPLE BALL MOVE BYTE
	CP 80H			;IS IT ACTIVE
	JP C,CRB14		;IF NOT MOVING GO CHECK THE NEXT ONE
	LD A,(IY)		;GET QBERTS MOVE BYTE
	CP 81H			;MOVING
	JP C,CRB13		;IF QBERT NOT MOVING TWO PLANE TEST
	CALL SOURDEST		;IF NOT IS SOURCE EQUAL TO DESTINATION
	CP 00H			;IS SOURCE = DESTINATION
	JP Z,CRB13		;IF EQUAL DO TWO PLANE COLLISION
	CALL DESTDEST		;CALL ROUTINE TO CHECK IF BOTH HAVE SAME DEST
	CP 00H			;WAS RESULT POSITIVE
	JP Z,CRB13		;IF TRUE GO DO TWO PLANE CHECK
	JP CRB14		;GO RETURN
CRB13:
	CALL TWOPLANE		;GO DO TWO PLANE COLLISION TEST
	CP 00H			;WAS COLLISION TEST VALID
	JP Z,COLLDEAD		;IF TRUE GO KILL QBERT
CRB14:
	RET
COLLDEAD:
	PCALL SOUND2,BHSO1	;MAKE SOUND WHEN BALL FALLS ON QBERT
	PCALL SOUND2,BHSO2
	PCALL SOUND2,C_OFF
COLLD1:	CALL QDEAD		;CALL ROUTINE TO KILL QBERT WITH COLLISION 
				;DEATH
	RET
;***END OF CODE THAT HANDLES COLLISION CHECKING
;
;***THIS ROUTINE HANDLES COMPARING PARAMETER 1 SOURCE AND PARAMETER 2
;	DEST. THE VALUE 00 IS RETURNED IF CONDITION MET
SOURDEST:
	LD A,(IX+1)		;GET PARM1 SOURCE X
	LD C,A			;MOVE IT TO C
	LD A,(IY+3)		;GET PARM2 DESTINATION X
	CP C			;ARE THEY EQUAL
	JP NZ,NOMATCH		;IF NOT GO RETURN NON ZERO IN A
	LD A,(IX+2)		;GET PARM1 SOURCE Y
	LD C,A			;MOVE TO C
	LD A,(IY+4)		;GET PARM 2 DEST Y
	CP C			;ARE THEY EQUAL
	JP NZ,NOMATCH		;IF NOT THEN GO RETURN NON ZERO IN A
	LD A,00H		;IF REACHED HERE PARM1 SOURCE = PARM2 DEST
	RET
NOMATCH:
	LD A,0FFH		;NO MATCH WAS FOUND SO RETURN NON ZERO VALUE 
	RET
;***END OF ROUTINE TO SEE IF PARM 1 SOURCE = PARM 2 DEST
;
;***THIS ROUTINE CHECKS THE DESTINATION OF PARM 1 AND THE DESTINATION OF
;PARM 2 AND RETURNS 0 IF THEY ARE EQUAL
DESTDEST:
	LD A,(IX+3)		;GET PARM1 DEST X
	LD C,A			;MOVE IT TO C
	LD A,(IY+3)		;GET PARM2 DESTINATION X
	CP C			;ARE THEY EQUAL
	JP NZ,NOMA2		;IF NOT GO RETURN NON ZERO IN A
	LD A,(IX+4)		;GET PARM1 DEST Y
	LD C,A			;MOVE TO C
	LD A,(IY+4)		;GET PARM 2 DEST Y
	CP C			;ARE THEY EQUAL
	JP NZ,NOMA2		;IF NOT THEN GO RETURN NON ZERO IN A
	LD A,00H		;IF REACHED HERE DEST SOURCE = PARM2 DEST
	RET
NOMA2:
	LD A,0FFH		;NO MATCH WAS FOUND SO RETURN NON ZERO VALUE 
	RET
;***END OF ROUTINE TO CHECK THE TWO DESTINATIONS
;
;***THIS ROUTINE DOES A SIMPLE TWO PLANE COLLISION TEST WITH
;	THE CHARACTER MATRICES PASSED IN IX AND IY. 00 RETURNED IF COND MET
TWOPLANE:
	LD A,(IX+6)		;GET THE CURRENT Y
	ADD A,08H		;GET BOTTOM COORDINATE OF THIS SPRITE
	LD C,A			;MOVE TO C
	LD A,(IY+6)		;GET PARM 2 Y
	CP C			;COMPARE THE TWO
	JP NC,TWONO		;IF A GREATER NO COLLISION
	LD A,C			;GET PARM 1 Y
	SUB 10H			;GET 1 SPRITE AREA ABOVE TOP OF THIS
	LD C,A
	LD A,(IY+6)		;GET PARM 2 Y
	CP C			;COMPARE THE TWO
	JP C,TWONO		;IF PARM 2 Y> PARM1+16 NO COLLISION
	LD A,(IX+5)		;GET PARM 1 X
	ADD A,08H		;GET LEFT MOST X OF THIS SPRITE
	LD C,A			;MOVE TO C
	LD A,(IY+5)		;GET PARM 2 X
	CP C			;COMPARE THE 2
	JP NC,TWONO		;IF PARM 2 LEFT EDGE >PARM1 X +16 NO COLLISION
	LD A,C
	SUB 10H			;GET LEFT EDGE - 16 OF PARM 1
	LD C,A			;MOVE IT BACK TO C
	LD A,(IY+5)		;GET PARM 1 X
	CP C			;COMPARE THE TWO
	JP C,TWONO		;IF LEFT OF THIS VALUE NO COLLISION
	LD A,00H		;IF IT REACHED HERE THERE IS A COLLISION
	RET
TWONO:
	LD A,0FFH		;NO COLLISION HAPPENED RETURN NON 0 IN A
	RET
;***END OF ROUTINE TO CHECK FOR TWO PLANE COLLISION
;
;***THIS ROUTINE WILL PUT UP THE BUBBLE WHEN QBERT DIES
QDEAD:
	LD IX,QCONTROL		;GET QBERT CONTROL MATRIX
	LD A,(IX)
	CP 80H
	JR Z,QDCONT
	;
	LD A,(IX+1)
	LD (IX+3),A
	LD A,(IX+2)
	LD (IX+4),A
QDCONT:
	LD (IX),00H		;DONT ALLOW THE PLAYER TO MOVE
	LD A,(IX+5)
	ADD A,10H		;GET X COORDINATE AND ADD 16 TO OFFSET BUBBLE
	LD L,A
	LD A,(IX+6)		;GET Y COORDINATE
	SUB 10H			;MOVE UP 16 PIXELS
	LD E,A
	LD A,SWEAR1		;A GETS THE SPRITE NUMBER
	LD C,A
	CALL SAVEALL		;SAVE THE CURRENT REGISTER VALUES
	CALL SPMOVE		;MOVE BUBBLE TO RIGHT PLACE
	CALL RESTALL		;RESTORE THE OLD REGISTER VALUES
	LD A,SWEAR2
	LD C,A
	CALL SAVEALL
	CALL SPMOVE		;MOVE LETTERS INTO BUBBLE
	CALL RESTALL
	LD A,SWEAR3		;GET SPRITE 3
	LD C,A
	LD A,L
	ADD A,10H		;ADD 16 TO X COORDINATE
	LD L,A
	CALL SAVEALL
	CALL SPMOVE		;PLACE BUBBLE UP
	CALL RESTALL 
	LD A,SWEAR4
	LD C,A
	CALL SPMOVE
	CALL FREEZE
	SETSK DEADDELAY,TASK24,01H,0FFH
	RET
;***THIS IS THE BUBBLE PUTTING ROUTINE
;
;***THIS ROUTINE WILL RATTACH THE TASKS REMOVED WHEN Q DIED
DEADDELAY:
	N.CLKRV TASK24		;REMOVE THIS TASK
	LD IX,QCONTROL		;GET CONTROL MATRIX ADDRESS
	LD (IX),80H		;ALLOW THE PLAYER TO MOVE NOW
	LD A,1
	LD (CDECFM),A		;SET FLAG THAT I HAVE DIED
	RET
;***END OF TASK THAT KILLS QBERT
;
;***THIS ROUTINE HANDLES MOVING THE DISK AND QBERT TO THE TOP
MOVEDISK:
	LD IX,QCONTROL		;GET QBERT CONTOL ADDRESS
	LD A,(ANGMOD)
	INC A
	LD (ANGMOD),A		;INCREMENT ANGLE MODIFICATION COUNT
	LD A,(IX+5)		;GET CURRENT X
	CP 120			;IS IT AT THE TOP?
	JP NZ,MDL1		;IF NOT EQUAL GO CHANGE THE X
	LD A,(IX+6)		;GET CURRENT Y
	CP 2			;IS IT AT THE HIGHEST POINT?
	JP Z,MDLFINISH		;IF SO WE ARE AT THE TOP?
	JP MDL2			;IF NOT GO CHANGE Y
MDL1:
	LD A,(ANGMOD)		;A GETS ANGLE MOD COUNT
	CP 6			;AT 6?
	JP NZ,ANGOK		;IF LESS CONTINUE FIXING X
	LD A,00H		
	LD (ANGMOD),A		;RESET THE ANGLE MODIFICATION COUNT
	JP MDL2			;GO FIX Y
ANGOK:
	LD A,(IX+5)		;GET CURRENT X
	CP 120			;IS IT AT THE TOP
	JP C,MDL3		;IF X IS LESS THAN THE MIDDLE OF THE TOP >
	DEC A			;ELSE SUBTRACT 1 FROM X
	LD (IX+5),A		;SAVE THE NEW X
	JP MDL2			;GO TRY TO FIX Y
MDL3:
	INC A			;ADD 1 TO X COORDINATE
	LD (IX+5),A		;SAVE THE NEW X
MDL2:
	LD A,(IX+6)		;GET CURRENT Y
	CP 3			;IS IT AT THE TOP
	JP C,MDL4		;IF LESS THAN 2 DONT RAISE ANY HIGHER
	DEC A			;SUBTRACT 1 FROM Y
	LD (IX+6),A		;SAVE NEW X VALUE
MDL4:
	LD A,(IX+5)		;GET CURRENT X
	LD (CURX),A		;SAVE IN TEMP VARIABLE
	LD A,(IX+6)		;GET THE CURRENT Y
	LD (CURY),A		;SAVE IN TEMP VARIABLE
	ADD A,4			;ADD 4 DOWN FOR THE DISK Y
	LD (CURY2),A		;SAVE IN TEMP VARIABLE
	PCALL SPMOVE,QBSPRITE,(CURY),(CURX)	;MOVE QBERT TO NEW SPOT
	PCALL SPMOVE,QBEYES,(CURY),(CURX)	;MOVE HIS EYES TOO
	PCALL SPMOVE,DISPRITE,(CURY2),(CURX)	;MOVE DISK TOO
	RET
MDLFINISH:
	N.CLKRV TASK23		;REMOVE THIS TASK
	LD A,120
	LD (IX+3),A		;SAVE DESTINATION X
	LD A,22		
	LD (IX+4),A		;SAVE THE DESTINATION Y
	LD A,85H
	LD (IX),A		;SET MOVE TO BE STRAIGHT DOWN
	PCALL SPMOVE,DISPRITE,0E0H,00H	;MOVE DISK SPRITE OUT OF THE WAY
	RET
;***END OF ROUTINE TO MOVE THE DISK TO THE TOP
;
;***THIS ROUTINE SIMPLY INCREMENTS A TIME COUNT WHICH IS USED TO DETERMINE
;WHEN EVENTS SHOULD START
UNICLOCK::
	LD A,(UNITIME)		;GET CURRENT TIME VALUE
	INC A			;ADD 1 TO COUNT
	LD (UNITIME),A		;SAVE NEW TIME INTO VARIABLE
	RET
;***END OF ROUTINE TO UPDATE UNIVERSAL TIME/EVENT COUNTER
;
;***THIS ROUTINE WILL SAVE ALL REGISTERS 
 SAVEALL::
	LD (SEMP1),A
	LD (SWORD1),BC
	LD (SWORD2),DE
	LD (SWORD3),HL
	LD (SWORD4),IX
	LD (SWORD5),IY
	RET
;** END OF ROUTINE TO SAVE ALL REGISTERS
;
;***THIS ROUTINE RESTORES ALL THE REGISTERS IN THE MANNER SAVED BY SAVEALL
RESTALL::
	LD A,(SEMP1)
	LD BC,(SWORD1)
	LD DE,(SWORD2)
	LD HL,(SWORD3)
	LD IX,(SWORD4)
	LD IY,(SWORD5)
	RET
;*** END OF ROUTINE TO RESTORE ALL REGISTERS
;
;***THIS ROUTINE DETERMINES WHAT ACTION IF ANY SHOULD BE TAKEN ON
;	THE FIRST RED BALL
MRED1::
	LD IX,RBALL1
	LD A,(IX)		;A GETS DIRECTION BYTE
	CP 80H			;IS IT ON BOARD AND NOT MOVING
	JP Z,MMRED1		;IF YES GO DECIDE WHERE NEXT
	RET
M1MRED1:
	LD A,85H		;TELL TO MOVE STRAIGHT DOWN
	LD (IX),A		;SET MOVE BYTE 
	LD A,104
	LD (IX+3),A		;SET DESTINATION X
	LD (IX+5),A		;SET CURRENT X
	LD A,00H
	LD (IX+6),A		;SET CURRENT Y
	LD A,42	
	LD (IX+4),A		;SET DESTINATION Y
	RET
MMRED1:
	LD A,(IX+6)
	CP 145			;OFF THE BOTTOM?
	JP C,M1MR3		;IF NOT GO PICK NEXT DESTINATION
	LD (IX),00		;LOAD MOVE BYTE TO MEAN INACTIVE
	RET
M1MR3:
;	PCALL SOUND2,BOUNCE	;GO MAKE MOVEMENT SOUND
	CALL LEFTORRIGHT	;GO GET A LEFT OR RIGHT DIRECTION
	LD (IX),A		;SAVE DIRECTION IN MOVE BYTE
	LD HL,RBALL1
	CALL DETDEST		;CALCULATE DESTINATION
	RET
;*** END OF ROUTINE TO HANDLE THE RED BALL
;
;***THIS ROUTINE HANDLES WHERE COILY WILL GO NEXT IF COILY IS ACTIVE
MCOILY:
	LD IX,COILY		;GET COILY CONTROL MATRIX
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS HE MOVING
	JP Z,MCO2		;IF NOT GO PICK A DIRECTION
	RET			;IF INACTIVE RETURN
MCO2:
	PCALL SPMOVE,PBSPRITE,0E0H,00H	;MOVE PURPLE BALL OUT OF THE WAY
	LD IY,QCONTROL		;IY GETS QBERT CONTROL MATRIX ADDRESS
	LD A,(IY)		;GET QBERT MOVE BYTE
	CP 00H			;IS HE ON A DISK OR FALLING?
	JP NZ,ONPYR		;IF NOT HE IS ONPYRAMID
	LD A,(IY+1)		;IF ON DISK USE THE COORDINATE OF THE DISK
	LD (QBERX),A		;TO DETERMINE WHERE TO MOVE COILY
	LD A,(IY+2)		;SET TO LAST SPOT ON PYRAMID
	LD (QBERY),A
	CP (IX+6)
	JR NZ,MCO25
	LD A,(QBERX)
	CP (IX+5)
	JR NZ,MCO25
	LD A,(IY+3)
	LD (QBERX),A
	LD A,(IY+4)
	LD (QBERY),A
	JP MCO25
ONPYR:
	LD A,(IY+5)		;IF ON PYRAMID USE THE CURRENT XY OF QBERT
	LD (QBERX),A		;TO DETERMINE WHERE TO MOVE COILY
	LD A,(IY+6)
	LD (QBERY),A
MCO25:
	LD A,(QBERY)		;GET QBERTS Y
	LD C,A
	LD A,(IX+6)		;GET COILYS CURRENT Y
	CP C			;COMPARE TO QBERTS LAST Y
	JP NC,MCO3		;IF COILY IS LOWER GO MOVE UP
PTCH2:	LD E,82H		;ELSE SET DIRECTION TO DOWN
	JP MCO4
MCO3:
	LD E,80H		;SET DIRECTION TO UP
MCO4:
	LD A,(QBERX)		;GET QBERTS X POSITION
	LD C,A
	LD A,(IX+5)		;GET COILYS CURRENT X
	CP C
	JP NC,MCO5		;IF COILY IS FURTHER RIGHT DET DIRECTION TO GO 
				;TO BE LEFT
	LD A,02H		;SET X DIRECTION TO BE RIGHT
	ADD A,E			;ADD X DIRECTION TO Y TO GET XY DIRECTION
	JP MCO6
MCO5:
	LD A,01H		;SET X DIRECTION TO BE LEFT
	ADD A,E			;ADD X DIRECTION TO Y TO GET XY DIRECTION
MCO6:
	LD (IX),A		;SAVE NEW DIRECTION
	LD HL,COILY		;HL GETS COILY CONTROL MATRIX ADDRESS
	CALL DETDEST		;GO GET DESTINATION COORDINATES
;
	LD A,(QCONTROL)
	CP 0
	RET Z			;IF QBERT IS INACTIVE THEN LET QOILY JUMP OFF
	LD IX,COILY		;GET COILY CONTROL MATRIX ADDRESS
	LD A,(IX+3)		;GET DESTINATION X
	ADD A,8
	LD C,A
	LD A,(IX+4)
	ADD A,10H
	LD E,A
	CALL QUERY
	CP 0FFH
	RET NZ
	LD A,(IX)		;GET MOVE BYTE
	ADD A,2			;MAKE HIM MOVE DOWN INSTEAD
	LD (IX),A
	LD HL,COILY
	CALL DETDEST
	RET
;***END OF ROUTINE TO HANDLE COILYS HUNT LOGIC
;
;***THIS ROUTINE MOVES SAM IF NEEDED
MSAM::
	LD IX,SAM
	LD A,(IX)		;A GETS DIRECTION BYTE
	CP 80H			;IS IT ON BOARD AND NOT MOVING
	JP Z,MSA3		;IF YES GO DECIDE WHERE NEXT
	RET 
MSA2:
	LD A,85H		;TELL TO MOVE STRAIGHT DOWN
	LD (IX),A		;SET MOVE BYTE 
	LD A,104
	LD (IX+3),A		;SET DESTINATION X
	LD (IX+5),A		;SET CURRENT X
	LD A,00H
	LD (IX+6),A		;SET CURRENT Y
	LD A,42	
	LD (IX+4),A		;SET DESTINATION Y
	RET
MSA3:
	LD A,(IX+6)
	CP 145			;OFF THE BOTTOM?
	JP C,MSA25		;IF NOT GO PICK NEXT DIRECTION
	LD (IX),00		;SET MOVE BYTE TO MEAN INACTIVE
	RET
MSA25:
	LD C,01H		;PASS CHARACTER NUMBER WHO IS JUMPING
	LD A,(IX+5)		;GET CURRENT X
	ADD A,8			;GIVE 8 OFFSET TO X
	LD E,A			;GIVE E THE CURRENT X
	LD A,(IX+6)		;GET CURRENT Y
	ADD A,10H		;ADD 16 TO Y
	LD L,A			;PASS Y COORDINATE TO 
	CALL FLIP
	CALL LEFTORRIGHT	;GO GET A LEFT OR RIGHT DIRECTION
	LD (IX),A		;SAVE DIRECTION IN MOVE BYTE
	RRC A			;VALUES RETURNED FROM LEFTORRIGHT ARE 83 AND 84
	JP NC,MSA4		;IF LOWEST BIT NOT SET MEANS 84 RETURNED
	PCALL SPNAME,SASPRITE,SDL	;FACE SAM DOWN AND TO THE LEFT
	JP MSA5
MSA4:
	PCALL SPNAME,SASPRITE,SDR	;FACE SAM DOWN AND RIGHT
MSA5:
	LD HL,SAM
	CALL DETDEST		;CALCULATE DESTINATION
	RET
;***END OF ROUTINE TO HANDLE SAM
;
;***THIS ROUTINE HAANDLES MOVEMENT OF SLICK
MSLICK:
	LD IX,SLICK
	LD A,(IX)		;A GETS DIRECTION BYTE
	CP 80H			;IS IT ON BOARD AND NOT MOVING
	JP Z,MSL3		;IF YES GO DECIDE WHERE NEXT
	RET 
MSL2:
	LD A,85H		;TELL TO MOVE STRAIGHT DOWN
	LD (IX),A		;SET MOVE BYTE 
	LD A,136
	LD (IX+3),A		;SET DESTINATION X
	LD (IX+5),A		;SET CURRENT X
	LD A,00H
	LD (IX+6),A		;SET CURRENT Y
	LD A,42	
	LD (IX+4),A		;SET DESTINATION Y
	RET
MSL3:
	LD A,(IX+6)
	CP 145			;OFF THE BOTTOM?
	JP C,MSL25		;IF NOT GO PICK NEXT DIRECTON
	LD (IX),00		;SET MOVE BYTE TO MEAN INACTIVE
	RET
MSL25:
	LD C,01H		;PASS CHARACTER NUMBER WHO IS JUMPING
	LD A,(IX+5)		;GET CURRENT X
	ADD A,8			;GIVE 8 OFFSET TO X
	LD E,A			;GIVE E THE CURRENT X
	LD A,(IX+6)		;GET CURRENT Y
	ADD A,10H		;ADD 16 TO Y
	LD L,A			;PASS Y COORDINATE TO 
	CALL FLIP
	CALL LEFTORRIGHT	;GO GET A LEFT OR RIGHT DIRECTION
	LD (IX),A		;SAVE DIRECTION IN MOVE BYTE
	RRC A			;ROTATE ACC TO SEE IF LOWEST BIT IS SET
	JP NC,MSL4		;IF NOT SET MEANS DIRECTION RETURNED WAS 84
	PCALL SPNAME,SLSPRITE,SLDL	;FACE SLICK DOWN AND LEFT
	PCALL SPNAME,SLGLASS,SUNL	;FACE GLASSES DOWN LEFT
	JP MSL5
MSL4:
	PCALL SPNAME,SLSPRITE,SLDR	;FACE SLICK DOWN AND RIGHT
	PCALL SPNAME,SLGLASS,SUNR	;SET GLASSES DOWN RIGHT
MSL5:
	LD HL,SLICK
	CALL DETDEST		;CALCULATE DESTINATION
	RET
;***END OF ROUTINME TO HANDLE SLICK MOVEMENT
;
;***THIS ROUTINE DETERMINES WHAT ACTION IF ANY SHOULD BE TAKEN ON
;	THE SECOND RED BALL
MRED2::
	LD IX,RBALL2
	LD A,(IX)		;A GETS DIRECTION BYTE
	CP 80H			;IS IT ON BOARD AND NOT MOVING
	JP Z,MMRED2		;IF YES GO DECIDE WHERE NEXT
	RET
M1MRE2:
	LD A,85H		;TELL TO MOVE STRAIGHT DOWN
	LD (IX),A		;SET MOVE BYTE 
	LD A,136
	LD (IX+3),A		;SET DESTINATION X
	LD (IX+5),A		;SET CURRENT X
	LD A,4
	LD (IX+6),A		;SET CURRENT Y
	LD A,42	
	LD (IX+4),A		;SET DESTINATION Y
	RET
MMRED2:
	LD A,(IX+6)
	CP 145			;OFF THE BOTTOM?
	JP C,M1MR6		;IF NOT GO PICK NEXT DIRECTION
	LD (IX),00H		;SET MOVE BYTE TO MEAN INACTIVE
	PCALL SPMOVE,B2SPRITE,0E0H,00H	;MOVE THE SPRITE OFF THE SCREEN
	RET
M1MR6:
	CALL LEFTORRIGHT	;GO GET A LEFT OR RIGHT DIRECTION
	LD (IX),A		;SAVE DIRECTION IN MOVE BYTE
	LD HL,RBALL2
	CALL DETDEST		;CALCULATE DESTINATION
	RET
;*** END OF ROUTINE TO HANDLE THE RED BALL
;
;THIS ROUTINE DETERMINES WHAT ACTION SHOULD BE TAKEN ON THE GREEN BALL
;IF ANY.
MGBALL:
	LD IX,GBALL		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80H
	JP Z,MG3LAB		;IF 80 GO DETERMINE WHICH DIRECTION NEXT
	RET 
MGB2:
	LD A,85H		;SET DIRECTION TO MOVE STRAIGHT DOWN
	LD (IX),A		;PUT BYTE INTO MATRIX
	LD A,104
	LD (IX+3),A		;SET DESTINATION X
	LD (IX+5),A		;SET CURRENT X
	LD A,00H
	LD (IX+6),A		;SET CURRENT Y
	LD A,42
	LD (IX+4),A		;SET DESTINATION Y
	RET
MG3LAB:
	LD A,(IX+6)		;GET CURRENT Y
	CP 145			;OFF THE BOTTOM?
	JP C,MGB27		;IF NOT GO PICK NEXT DIRECTION
	LD (IX),0		;SET MOVE BYTE TO MEAN INACTIVE
	RET
MGB27:
	CALL LEFTORRIGHT	;GO GET LEFT OR RIGHT DIRECTION
	LD (IX),A		;SAVE NEW DIRECTION IN MOVE BYTE
	LD HL,GBALL
	CALL DETDEST		;GO DETERMINE DESTINATION
	RET
;*** END OF ROUTINE TO DETERMINE ACTION FOR GREEN BALL
;
;***THIS ROUTINE WILL DETERMINE THE ACTION TO BE TAKEN ON THE PURPLE BALL IF
;ANY.
MPBALL:
	LD IX,PBALL		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80H
	JP Z,MP3LAB		;IF 80 GO DETERMINE WHICH DIRECTION NEXT
	RET
MPB2:
	LD IY,COILY		;GET COILY CONTROL MATRIX ADDRESS
	LD A,(IY)		;GET MOVE BYTE
	CP 7FH
	RET NC			;IF COILY IS MOVING THEN DON'T START A NEW
				;PURPLE BALL FALLING
	LD A,1
	LD (UNISTOP),A		;SET FLAG TO MEAN 1 CHARACTER ALREADY STARTED
	LD A,85H		;SET DIRECTION TO MOVE STRAIGHT DOWN
	LD (IX),A		;PUT BYTE INTO MATRIX
	LD A,136
	LD (IX+3),A		;SET DESTINATION X
	LD (IX+5),A		;SET CURRENT X
	LD A,03H
	LD (IX+6),A		;SET CURRENT Y
	LD A,42
	LD (IX+4),A		;SET DESTINATION Y
	RET
MP3LAB:
	LD A,(IX+6)		;GET CURRENT Y
	CP 138			;OFF THE BOTTOM?
	JP C,MPB4		;STILL ON PYRAMID GO GET A DIRECTION
	LD IY,COILY		;IY GETS COILY CONTROL MATRIX
	LD A,(IX+5)		;GET BALLS CURRENT X
	LD (IY+5),A		;SET COILYS CURRENT X TO SAME VALUE
	LD A,(IX+6)		;GET BALLS CURRENT Y
	LD (IY+6),A		;SET COILYS CURRENT Y TO THE SAME
	LD A,80H
	LD (IY),A		;SET COILY MOVE BYTE TO MEAN ACTIVE
	LD A,00H
	LD (IX),A		;TELL PURPLE BALL NOT TO MOVE ANYMORE
	RET
MPB4:
	CALL LEFTORRIGHT	;GO GET LEFT OR RIGHT DIRECTION
	LD (IX),A		;SAVE NEW DIRECTION IN MOVE BYTE
	LD HL,PBALL
	CALL DETDEST		;GO DETERMINE DESTINATION
	RET
;***END OF ROUTINE TO DETERMINE WHAT ACVTION IS TO BE TAKEN ON THE
;PURPLE BALL IF ANY
;
;***THIS ROUTINE HANDLES THE MOVEMENT OF UGH IF ANY.
MUGH::
	LD IX,UGH		;GET CONTROL MATRIX FOR UGH
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80
	JP Z,MUGH3		;IF SO GO DETERMINE NEXT DIRECTION
	RET 
MUGH2:
	LD A,86H		;SET DIRECTION TO BE STRAIGHT LEFT
	LD (IX),A		;PUT MOVE BYTE IN CONTROL MATRIX
	LD A,232		;SET DESTINATION X
	LD (IX+3),A		;SAVE DESTINATION X
	LD A,240
	LD (IX+5),A		;SAVE CURRENT X
	LD A,160		;SET Y
	LD (IX+4),A		;SET DESTINATION Y
	LD (IX+6),A		;SET CURRENT Y
	RET
MUGH3:
MUGH4:
	CALL UPLERI		;CALL ROUTINE TO DETERMINE UP LEFT OR RIGHT
	LD (IX),A		;SAVE DIRECTION INTO MOVE BYTE IN MATRIX
	LD HL,UGH		;GET ADDRESS OF UGH CONTROL MATRIX
	CALL DETDEST		;GO FIND DESTINATION COORDINATES
	LD A,(IX+3)		;GET DESTINATION X
	SRL A
	SRL A
	SRL A			;DIVIDE BY 8 TO GET PATTERN X COORDINATE
	LD C,A			;MOVE RESULT TO C
	LD A,(IX+4)		;GET DESTINATION Y LOCATION
	SRL A
	SRL A
	SRL A			;DIVIDE BY 8 TO GET THE PATTERN Y COORDINATE
	LD E,A			;E GETS THE PATTERN Y COORDINATE
	CALL GETPAT		;GO GET PATTERN UNDER UGH
	CP 1			;IS PATTERN LESS THAN 1
	JP C,MUGH5		;IF LESS THAN 1 HE IS OF PYRAMID
	CP 79H			;LESS THAN 69
	JP NC,MUGH5		;IF GREATER HE IS OFF PYRAMID
	JP MUGH6		;GO DETERMINE SPRITE NAME
MUGH5::
	LD A,86H		;SET DIRECTIN TO STRAIGHT LEFT
	LD (IX),A		;PUT BYTE IN MOVE MATRIX
	LD (IX+3),10		;SET DESTINATION X TO 30
	LD A,(IX+6)		;GET CURRENT Y
	LD (IX+4),A		;SAVE THE DESTINATION Y
MUGH6:
	LD A,(IX)		;GET MOVE DIERCION BYTE
	CP 86H
	JP NZ,MUGH7		;IF NOT STRAIGHT LEFT THEN NAME UP LEFT
	PCALL SPNAME,UGSPRITE,USL
	RET
MUGH7:
	PCALL SPNAME,UGSPRITE,UUL	;FACE UGH UP AND LEFT
	RET
;*** END OF ROUTINE TO HANDLE UGH MOVEMNET.
;
;*** THIS ROUTINE HANDLES THE MOVEMENT OF WRONG WAY IF ANY
; IS NEEDED.
MWRONG:
	LD IX,WRONG		;GET CONTROL MATRIX FOR UGH
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80
	JP Z,MWR3		;IF SO GO DETERMINE NEXT DIRECTION
	RET 
MWR2:
	LD A,87H		;SET DIRECTION TO BE STRAIGHT LEFT
	LD (IX),A		;PUT MOVE BYTE IN CONTROL MATRIX
	LD A,08H		;SET DESTINATION X
	LD (IX+3),A		;SAVE DESTINATION X
	LD A,00H
	LD (IX+5),A		;SAVE CURRENT X
	LD A,160		;SET Y
	LD (IX+4),A		;SET DESTINATION Y
	LD (IX+6),A		;SET CURRENT Y
	RET
MWR3:
MWR4:
	CALL WPLERI		;CALL ROUTINE TO DETERMINE UP RIGHT OR RIGHT
	LD (IX),A		;SAVE DIRECTION INTO MOVE BYTE IN MATRIX
	LD HL,WRONG		;GET ADDRESS OF UGH CONTROL MATRIX
	CALL DETDEST		;GO FIND DESTINATION COORDINATES
	LD A,(IX+3)		;GET DESTINATION X
	ADD A,10H		;ADD 16 WE WANT THE RIGHT EDGE WHERE THE FEET ARE
	SRL A
	SRL A
	SRL A			;DIVIDE BY 8 TO GET PATTERN X COORDINATE
	LD C,A			;MOVE RESULT TO C
	LD A,(IX+4)		;GET DESTINATION Y LOCATION
	SRL A
	SRL A
	SRL A			;DIVIDE BY 8 TO GET THE PATTERN Y COORDINATE
	LD E,A			;E GETS THE PATTERN Y COORDINATE
	CALL GETPAT		;GO GET PATTERN UNDER UGH
	CP 1			;IS PATTERN LESS THAN 1
	JP C,MWR5		;IF LESS THAN 1 HE IS OF PYRAMID
	CP 79H			;LESS THAN 69
	JP NC,MWR5		;IF GREATER HE IS OFF PYRAMID
	JP MWR6	        	;GO DETERMINE SPRITE NAME
MWR5::
	LD A,87H		;SET DIRECTIN TO STRAIGHT RIGHT
	LD (IX),A		;PUT BYTE IN MOVE MATRIX
	LD (IX+3),235		;SET DESTINATION X TO 235
	LD A,(IX+6)		;GET CURRENT Y
	LD (IX+4),A		;SAVE THE DESTINATION Y
MWR6:
	LD A,(IX)		;GET MOVE DIERCION BYTE
	CP 87H
	JP NZ,MWR7		;IF NOT STRAIGHT RIGHT THEN NAME UP RIGHT
	PCALL SPNAME,WRSPRITE,WSR
	RET
MWR7:
	PCALL SPNAME,WRSPRITE,WUR	;FACE WRONG WAY UP RIGHT
	RET
;***END OF ROUTINE TO HANDLE WRONG WAY
;
;**THIS SECTION MOVES THE CHARACTERS IF NEEDED
;EACH OF THESE ARE SEPERATE INTERUPT SUBROUTINES SO EACH CAN
;RUN AT A DIFFERENT SPEED
;
M2MRED1:
	LD IX,RBALL1		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80 OR GREATER
	JP Z,TLAB20		;IF 80 GO MAKE BALL FLAT ON THE BOTTOM
	RET C			;IF NOT RETURN
	PCALL SPNAME,B1SPRITE,TEB	;MAKE THIS BALL RED
	LD HL,RBALL1
	CALL MOVECHAR		;GO MOVE CHARACTER
	RET
TLAB20:
	PCALL SPNAME,B1SPRITE,TEBF	;MAKE THIS BALL FLAT ON THE BOTTOM
	RET
;**************************************************
M2MRE2:
	LD IX,RBALL2		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80 OR GREATER
	JP Z,TLAB21		;IF 80 GO MAKE BALL FLAT ON THE BOTTOM
	RET C			;IF NOT RETURN
	PCALL SPNAME,B2SPRITE,TEB	;MAKE THIS BALL ROUND
	LD HL,RBALL2
	CALL MOVECHAR		;GO MOVE CHARACTER
	RET
TLAB21:
	PCALL SPNAME,B2SPRITE,TEBF	;MAKE THIS BALL FLAT ON THE BOTTOM
	RET
;************************************************
M2MRE3:
	LD IX,GBALL		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80 OR GREATER
	JP Z,TLAB22		;IF 80 GO MAKE BALL FLAT ON THE BOTTOM
	RET C			;IF NOT RETURN
	PCALL SPNAME,GBSPRITE,EIB	;MAKE THIS BALL ROUND
	LD HL,GBALL
	CALL MOVECHAR		;GO MOVE CHARACTER
	RET
TLAB22:
	PCALL SPNAME,GBSPRITE,EIBF	;MAKE THIS BALL FLAT ON THE BOTTOM
	RET
;*************************************************
M2MRE4:
	LD IX,PBALL		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 80H			;IS IT 80 OR GREATER
	JP Z,TLAB23		;IF 80 MAKE BALL FLAT ON THE BOTTOM
	RET C			;IF NOT RETURN
	PCALL SPNAME,PBSPRITE,TWB	;MAKE THIS BALL ROUND
	LD HL,PBALL
	CALL MOVECHAR		;GO MOVE CHARACTER
	RET
TLAB23:
	PCALL SPNAME,PBSPRITE,TWBF	;MAKE THIS BALL FLAT ON THE BOTTOM
	RET
;**************************************************
M2MRE5:
	LD IX,UGH		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 81H			;IS IT 81 OR GREATER
	RET C			;IF NOT RETURN
	LD HL,UGH
	CALL MOVECHAR		;GO MOVE CHARACTER
	LD IX,UGH		;GET UGHS CONTROL MATRIX
	LD A,(IX+5)		;GET CURRENT X
	CP 16
	RET NC			;IF GREATER THAN 16 JUST RETURN
	LD (IX),00		;SET MOVE BYTE TO MEAN NOT ACTIVE
	PCALL SPMOVE,UGSPRITE,0E0H,00H	;MOVE UGH OFF THE SCREEN
	RET
;******************************************************
M2MRE6:
	LD IX,WRONG		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 81H			;IS IT 81 OR GREATER
	RET C			;IF NOT RETURN
	LD HL,WRONG
	CALL MOVECHAR		;GO MOVE CHARACTER
	LD IX,WRONG		;IX GETS WRONG WAY MATRIX ADDRESS
	LD A,(IX+5)		;GET CURRENT X
	CP 233			;LEFT EDGE
	RET C			;IF NOT GREATER RETURN
	LD (IX),0		;SET MOVE BYTE TO MEAN NOT ACTIVE
	PCALL SPMOVE,WRSPRITE,0E0H,00H	;MOVE WRONG WAY OUT OF THE SCREEN
	RET
;*****************************************************
M2MRE7:
	LD IX,SAM		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 81H			;IS IT 81 OR GREATER
	RET C			;IF NOT RETURN
	LD HL,SAM
	CALL MOVECHAR		;GO MOVE CHARACTER
	RET
;******************************************************
M2MRE8:
	LD IX,SLICK		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 81H			;IS IT 81 OR GREATER
	RET C			;IF NOT RETURN
	LD HL,SLICK
	CALL MOVECHAR		;GO MOVE CHARACTER
	LD IX,SLICK		;GET SLICKS CONTROL MATRIX
	LD C,SLGLASS		;C GETS THE SPRITE NUMBER
	LD A,(IX+6)		;GET THE CURRENT Y FOR SLICK
	LD E,A			;E GETS THE Y
	LD A,(IX+5)		;GET THE CURRENT X FOR SLICK
	LD L,A			;L GETS THE X
	CALL SPMOVE		;GO MOVE IT

	RET
;*******************************************************
M2MRE9:
	LD IX,COILY		;GET CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET MOVE BYTE
	CP 81H			;IS IT 81 OR GREATER
	RET C			;IF NOT RETURN
	LD HL,COILY
	CALL MOVECHAR		;GO MOVE CHARACTER
	LD A,(IX+8)		;GET JUMP COUNT
	CP 0FFH			;IS IT FFH
	JP Z,M2NOMOVE		;IF IT IS IT MANS COILY IS PASSING BEHIND PYR.
	LD IX,COILY		;GET COILY MATRIX ADDRESS
	LD C,CTSPRITE		;C GETS THE SPRITE NUMBER
	LD A,(IX+6)		;A GETS THE BOTTOM SPRITES Y COORD
	SUB 16			;SUBTRACT 16 TO GET Y FOR TOP HALF OF COILY
	LD E,A			;MOVE RESULT TO E
	LD A,(IX+5)		;GET THE CURRENT X
	LD L,A			;MOVE X TO L
	CALL SPMOVE		;GO MOVE TOP SPRITE
	JP M2CONT
M2NOMOVE:
	PCALL SPMOVE,CTSPRITE,0E0H,00H	;MOVE TOP OF COILY OUT OF WAY
M2CONT:
	LD A,(EXPCOUNT)		;GET THE EXPANSION COUNTER
	INC A			;ADD 1 TO THE COUNT
	LD (EXPCOUNT),A		;SAVE NEW COUNT
	CP 12			;IS NUMBER GREATER THAN 6
	JP NC,ALLEXP		;IF SO COILY IS FULLY EXPANDED
	CP 6			;IS IT GREATER THAN 3
	JP NC,HALFEXP		;IF SO IT IS HALF EXPANDED
	PCALL SPNAME,CBSPRITE,CPH5	
	PCALL SPNAME,CTSPRITE,CLEARSP
	JP DONEANIM
HALFEXP:
	PCALL SPNAME,CBSPRITE,CPH4
	PCALL SPNAME,CTSPRITE,CPH3
	JP DONEANIM
ALLEXP:
	PCALL SPNAME,CBSPRITE,CPH2
	PCALL SPNAME,CTSPRITE,CPH1
DONEANIM:
	LD A,(IX)		;GET CONTENETS OF  MOVE BYTE
	CP 80H			;IS IT NOT MOVING
	RET NZ			;IF MOVING RETURN
	LD A,(IX+6)		;GET CURRENT Y
	CP 193			;AT THE BOTTOM OF FALL?
	JP C,M2ML10		;IF NOT
	PCALL SPMOVE,CTSPRITE,0E0H	;MOVE TOP SPRITE OUT OF WAY
	LD (IX),00		;SET COILY MOVE BYTE TO MEAN INACTIVE
	PCALL ADDSCORE,500H	;ADD 500 POINTS TO SCORE
	RET
M2ML10:
	LD A,(IX+5)
	ADD A,8			;OFFSET X TO BE IN MIDDLE OF DISK
	LD C,A			;C GETS X COORDINATE
	LD A,(IX+6)
	ADD A,10H
	LD E,A			;E GETS Y
	CALL QUERY		;GO SEE IF HE IS NOT ON ANYTHING
	CP 0FFH			;IS HE IN MID AIR?
	JP Z,STFALL		;IF HE IS NOT ON A CUBE START FALL
	CP 28
	JR C,COCONT
	CP 42
	JR NC,COCONT
	JP STFALL		;IF ON A DISK MAKE HIM FALL THROUGH
COCONT:
	PCALL SPNAME,CBSPRITE,CPH5
	PCALL SPNAME,CTSPRITE,CLEARSP
	XOR A			;A GETS 0
	LD (EXPCOUNT),A		;RESET THE EXPANSION COUNT
	RET
STFALL:
	PUSH IX			;SAVE IX REGISTER
	PCALL SOUND2,CFSO1	;START COILY FALLING SOUND
	PCALL SOUND2,CFSO2
	PCALL SOUND2,C_OFF
	CALL SABQAC		;THIS ROUTINE STOPS ALL CHARACTERS BUT QBERT
				;AND COILY.THIS IS CALLED WHEN COILY IS FALLING
	POP IX			;RESTORE IX
	LD (IX),88H		;SET DIRECTION TO STRAIGHT DOWN IN DEATH FALL
	LD (IX+4),195		;SET DESTINATION Y TO 195
	RET
;*** END OF ROUTINE TO HANDLE THE CHARACTER MOVEMENT
;
;***THIS ROUTINE STOPS ALL THE CHARACTERS BUT QBERT AND COILY WHEN COILY IS
;	FALLING
SABQAC:
	LD IX,UGH		;GET START ADDRESS OF CONTROL MATRICES
	XOR A			;CLEAR ACCUMULATOR
	LD (IX),A		;SET UGH TO INACTIVE
	LD (IX+8),A		;RESET JUMP VARIABLE
	LD (IX+9),A		;STOP WRONG
	LD (IX+17),A		;RESTET JUMP VARIABLE
	LD (IX+27),A		;STOP SAM
	LD (IX+35),A		;RESET JUMP COUNT
	LD (IX+36),A		;STOP SLICK
	LD (IX+44),A		;RESET JUMP VARIABLE
	LD (IX+45),A		;
	LD (IX+53),A		;STOP 
	LD (IX+54),A
	LD (IX+62),A
	LD (IX+63),A
	LD (IX+71),A
	LD (IX+72),A
	LD (IX+80),A
; THE ROUTINE SPMOVE USUALLY REQUIRES A THIRD PARAMETER WHICH IS THE X COORD
; BUT SEEING WE ARE NOT CONCERNED WITH THE X, WE DON'T SPECIFY 1 AND SAVE 3
; BYTES FOR EACH CALL.
	PCALL SPMOVE,UGSPRITE,0E0H
	PCALL SPMOVE,WRSPRITE,0E0H
	PCALL SPMOVE,SASPRITE,0E0H
	PCALL SPMOVE,SLSPRITE,0E0H
	PCALL SPMOVE,B1SPRITE,0E0H
	PCALL SPMOVE,B2SPRITE,0E0H
	PCALL SPMOVE,GBSPRITE,0E0H
	PCALL SPMOVE,SLGLASS,0E0H
	LD A,6
	LD (GR1DEL),A
	LD A,(GR3DEL)		;GET INITIAL DELAY FOR UGH AND WRONGWAY
	CP 6
	RET NC
	LD A,6
	LD (GR3DEL),A		;IF DELAY WAS LESS THAN 6 SET TO 6
	RET
;***THIS IS THE END OF THE STO ALL ROUTINE
;
;***THIS ROUTINE PICKS A RANDOM LEFT OR RIGHT DIRECTIN USING THE CONTENTS
;	OF THE REFRESH REGISTER 
LEFTORRIGHT:
	LD A,R		;GET REFRESH VALUE INTO A
	RLC A
	RLC A
	RLC A
	RLC A
	JP NC,GLEFT	;IF NOT ASIGN DIRECTION LEFT
	LD A,84H	;SET DIRECTION TO DOWN AND RIGHT
	RET
GLEFT:
	LD A,83H	;SET DIRECTION TO DOWN AND LEFT
	RET
;***END OF ROUTINE TO DETERMINE DOWN LEFT OR DOWN RIGHT DIRECTION
;
;***THIS ROUTINE PICKS A RANDOM UP LEFT OR STRAIGHT LEFT VALUE
UPLERI:
	LD A,R		;GET REFRESH VALUE INTO A
	RLC A
	RLC A
	RLC A
	RLC A
	JP NC,LERI2	;IF NOT ASIGN DIRECTION LEFT
	LD A,81H	;SET DIRECTION TO UP AND RIGHT
	RET
LERI2:
	LD A,86H	;SET DIRECTION TO UP AND LEFT
	RET
;***END OF ROUTINE TO PICK A RANDOM DIRECTION FOR UGH
;
;***THIS ROUTINE PICKS A RANDOM UP RIGHT OR STRAIGHT RIGHT VALUE
WPLERI:
	LD A,R		;GET REFRESH VALUE INTO A
	RLC A
	RLC A
	RLC A
	RLC A
	JP NC,WLERI2	;IF NOT ASIGN DIRECTION LEFT
	LD A,82H	;SET DIRECTION TO UP AND RIGHT
	RET
WLERI2:
	LD A,87H	;SET DIRECTION TO UP AND LEFT
	RET
;***END OF ROUTINE TO GENERATE A UP RIGHT OR STRAIGHT RIGHT DIRECTION
;
;***THIS ROUTINE MOVES QBERT AAROUND FOR THE DEMO
FORCEQ::
	LD HL,(DPTR)		;GET DATA POINTER
	LD A,(HL)		;GET THE BYTE THE POINTER IS AT
	PUSH AF			;SAVE TABLE VALUE
	CP 00			;IS IT THE LAST BYTE IN DEMO TABLE
	JP NZ,GOINC		;IF NOT GO INCREMENT DATA POINTER
	LD A,1
	LD (DEMODONE),A		;SET FLAG TO SHOW DEMO IS FINISHED
GOINC:
	INC HL			;ADVANCE THE POINTER
	LD (DPTR),HL		;SAVE THE NEW POINTER
	POP AF			;RETURN TABLE VALUE OBTAINED TO ACCUMULATOR
	RET
;***END OF ROUTINE TO MOVE QBERT FOR THE DEMO
;
;***THIS ROUTINE DETERMINES WETHER TO MOVE Q OR NOT
MOVQBERT::
	LD HL,QCONTROL		;HL GETS ADDRESS OF QBERT CONTROL MATRIX
	LD A,(HL)		;A GETS FIRST BYTE OF MATRIX
	CP 00H			;IS THE MOVE BYTE 00
	RET Z			;THIS MEANS THE CHARACTER SHOULDNT MOVE
	AND 7FH			;REMOVE UPPER BIT
	RET NZ			;IF NON ZERO DON'T MOVE	
	LD A,(INDEMO)		;GET CONTENTS OF DEMO FLAG
	CP 1			;IS DEMO ACTIVE
	JR NZ,GJVAL		;IF NOT GO GET JOYSTICK VALUE
	CALL FORCEQ		;IF IN DEMO GO FAKE JOYSTICK VALUE TO MOVE
				;QBERT IN THE DEMO PATTERN
	JR GNVAL		;GO TO WHERE JOY VALUE IS INTERPRETED
GJVAL:
	CALL JOYVAL		;GET JOYSTICK VALUE
GNVAL:
	CP 00H			;CHECK IF DEVICE READY
	RET Z			;RETURN IF NOT READY
	LD (JOYDIR),A		;GET RETURNED JOYSTICK VALUE
	LD HL,QCONTROL		;PUT QBERT CONTROL ADDRESS BACK IN HL
	LD A,(JOYDIR)		;ELSE JOYDIR GETS RETURNED DIRECTION
	CP UP			;COMPARE DIRECTION TO UP
	JP NZ,CDOWN		;NOT EQUAL JUMP TO CHECK DOWN
	LD A,82H		;SET DIRECTION TO UP AND RIGHT
	LD (HL),A		;PLACE DIRECTION IN FIRST BYTE OF CONTROL
	CALL SAVEALL		;SAVE CURRENT REGISTERS ON THE STACK
	PCALL SPNAME,QBSPRITE,QUR	;MAKE QBERT FACE UP AND RIGHT
	PCALL SPNAME,QBEYES,QEUR	;MAKE EYES UP RIGHT
	CALL RESTALL		;RESTORE REGISTERS
	JP SETDEST
CDOWN:
	LD A,(JOYDIR)		;A GETS DIRECTION
	CP DOWN			;IS IT DOWN?
	JP NZ,CLEFT		;IF NOT GO CHECK LEFT DIRECTION
	LD A,83H		;SET DIRECTION TO DOWN AND LEFT
	LD (HL),A		;SET FIRST BYTE IN CONTROL MATRIX
	CALL SAVEALL		;SAVE CURRENT REGISTER VALUES
	PCALL SPNAME,QBSPRITE,QDL	;MAKE QBERT FACE DOWN AND LEFT
	PCALL SPNAME,QBEYES,QEDL	;MAKE EYES FACE DOWN LEFT
	CALL RESTALL		;RESTORE THE REGISTERS
	JP SETDEST
CLEFT:
	LD A,(JOYDIR)		;A GETS JOYSTICK DIRECTION
	CP LEFT			;IS IT LEFT?
	JP NZ,CRIGHT		;IF NOT GO CHECK RIGHT
	LD A,81H		;SET DIRECTION TO UP AND LEFT
	LD (HL),A		;SET DIRECTION IN CONTROL MATRIX
	CALL SAVEALL		;SAVE CURRENT REGISTER VALUES
	PCALL SPNAME,QBSPRITE,QUL	;MAKE QBERT FACE UP AND LEFT
	PCALL SPNAME,QBEYES,QEUL	;MAKE EYES FACE UP LEFT
	CALL RESTALL		;RESTORE THE REGISTERS
	JP SETDEST
CRIGHT:
	LD A,(JOYDIR)		;A GETS THE JOYSTICK DIRECTION
	CP RITE			;IS IT RIGHT
	RET NZ			;IF NOT RET BECAUSE NOT ONE OF 4 DIRECTIONS
	LD A,84H		;SET DIRECTION TO DOWN AND RIGHT
	LD (HL),A		;SET DIRECTION BYTE IN CONTROL MATRIX
	CALL SAVEALL		;SAVE THE CURRENT REGISTER VALUES
	PCALL SPNAME,QBSPRITE,QDR	;MAKE QBERT FACE DOWN AND RIGHT
	PCALL SPNAME,QBEYES,QEDR	;MAKE EYES FACE DOWN RIGHT
	CALL RESTALL		;RESTORE THE REGISTERS
SETDEST:
	LD HL,QCONTROL		;PASS CONTROL ADDRESS IN HL
	CALL DETDEST		;CALL ROUTINE TO DETERMINE DESTINATION
				;OF QBERT AND FIX BYTES IN CONTROL MATRIX
	RET
;
;***END OF ROUTINE TO DETERMINE WETHER TO MOVE QBERT
;
;***THIS ROUTINE GETS THE VALUE OF THE JOYSTICK AND RETURNS THE 
;   VALUE IN THE ACCUMULATOR.
JOYVAL::
	LD A,(GAMEOPT)	;GET THE GAME OPTION
	CP 3		;IS IT TWO PLAYER TWO JOYSTICK
	JP NZ,JOYV1
	LD A,(PLAYER)	;IS IT PLAYER TWO
	CP 1
	JP Z,JOYV2	;IF SO GO GET SECOND JOYSTICK INPUT
JOYV1:
	N.DEVRDY	KEYBOARD,JSTCK1
	CP 00H
	JP NZ,GETNEW	;IF CHANGE GO GET NEW VALUE
	LD A,(OLDVAL)	;ELSE RETURN LAST VALUE
	RET
JOYV2:
	N.DEVRDY	KEYBOARD,JSTCK2
	CP 00H
	JP NZ,GETN2	;IF CHANGE GO GET NEW VALUE
	LD A,(OLDVAL)	;ELSE RETURN LAST VALUE
	RET
GETNEW:
	N.DEVIO KEYBOARD,JSTCK1
	JR GETN3
GETN2:
	N.DEVIO KEYBOARD,JSTCK2
GETN3:
	AND 0FH			;REMOVE UPPER FOUR BITS
	LD (OLDVAL),A
	RET
;
;***END OF ROUTINE TO GET JOYSTICK VALUE
;
;*** THIS ROUTINE IS TESTED TO SEE IF Q_BERT IS BETWEEN SQUARES
;	IF SO CALL ROUTINE TO MOVE HIM
M_QBERT::
	LD HL,QCONTROL		;HL GETS QBERT CONTROL MATRIX
	LD A,(HL)		;A GETS FIRST BYTE OF MATRIX
	CP 00H			;IS MOVE VALUE SET TO 00
	RET Z			;IF SO DONT MOVE QBERT
	AND 7FH			;REMOVE UPPER BIT
	RET Z			;IF NOT > 0 THEN RETURN
	LD HL,QCONTROL		;HL GETS ADDRESS OF CHARACTER CONTROL MATRIX
	CALL MOVECHAR		;CALL UNIVERSAL SPRITE MOVING ROUTINE
				;WITH CONTROL ADDRESS IN HL
	LD IX,QCONTROL		;GET QBERTS CONTROL MATRIX
	LD A,(IX+8)		;GET PHASE SHIFT BYTE
	CP 0FFH			;IS QBERT BEHIND PYRAMID?
	JP Z,M_NOMOVE		;IF SO MOVE EYES OUT OF THE WAY
	LD C,QBEYES		;C GETS SPRITE NUMBER
	LD A,(IX+6)		;GET CURRENT Y
	LD E,A			;E GETS Y COORD
	LD A,(IX+5)		;GET CURRENT X
	LD L,A			;L GETS THE X
	CALL SPMOVE		;GO MOVE IT
	JP M_CONT
M_NOMOVE:
	PCALL SPMOVE,QBEYES,0E0H,00H	;MOVE QBERTS EYES OFF THE SCREEN
M_CONT:
	LD A,(IX)		;GET MOVE BYTE
	AND 7FH
	RET NZ			;IF STILL MOVING DON'T FLIP
	LD C,00H		;PASS CHARACTER NUMBER WHO IS JUMPING
	LD A,(IX+5)		;GET CURRENT X
	ADD A,8			;GIVE 8 OFFSET TO X
	LD E,A			;GIVE E THE CURRENT X
	LD A,(IX+6)		;GET CURRENT Y
	ADD A,10H		;ADD 16 TO Y
	LD L,A			;PASS Y COORDINATE TO 
	CALL FLIP
	LD (FLIPRET),A		;SAVE THE VALUE THAT WAS RETURNED
	CP 0FFH			;IS THERE NOTHING WHERE I JUMPED?
	JP NZ,MQLAB1		;IF SOMETHING WAS THERE THEN RETURN
	LD A,(IX+4)		;GET CURRENT Y
	CP 200			;IS IT STOPPED BELOW SCREEN
	RET NC			;IF YES THEN RETURN
	LD (IX),88H		;SET DIRECTION TO STRAIGHT DOWN DEATH FALL
	LD (IX+4),220		;SET DESTINATION TO OFF THE BOTTOM OF SCREEN
	PCALL SOUND2,QFSO1	;MAKE QBERT FALLING SOUND
	PCALL SOUND2,QFSO2
	PCALL SOUND2,C_OFF
	SETSK QFALLING,TASK22,1,1	;SET TASK TO CHECK FOR END OF FALL
	N.CLKRV TASK1		;REMOVE THE QBERT JOYSTICK CONTROL TASK
	CALL FREEZE		;STOP ALL OTHER CHARACTERS
	RET
MQLAB1:
	LD A,(FLIPRET)		;A GETS THE VALUE RETURNED FROM FLIP ROUTINE
	CP 28	
	RET C			;IF LESS THAN 29 NOT ON A DISK
	CP 42
 	RET NC			;IF GREATER THAN 41 NOT ON A DISK
	LD A,00H
	LD (ANGMOD),A		;RESET THE ANGLE MODIFICATION COUNT
	LD E,00H
	LD A,(IX+6)		;GET CURRENT Y
	LD C,A			;C REGISTER GETS THE CURRENT Y
	LD A,120		;120 IS THE LOWEST Y COORDINATE FOR A DISK
MQLAB2:
	SUB C			;SUBTRACT Y COORDINATE
	INC E			;INCREMENT DELAY COUNTER
	JP NC,MQLAB2		;LOOP UNTIL LESS THAN 0
	LD A,E			;GET COUNT
	CP 7			;IS INTERUPT COUNT LESS OR = 6
	JP C,DCOK		;IF SO DISK DELAY IS OK
	LD A,08H		;ELSE SET SPEED FOR DISK AT EVERY 8 IONTS
DCOK:
	LD (INTCOUNT),A		;SAVE RESULTANT INTERUPT SPEED
	PCALL SOUND2,DASO1	;START DISK ASCENDING SOUND
	PCALL SOUND2,B_OFF
	PCALL SOUND2,C_OFF
	SETSK MOVEDISK,TASK23,(INTCOUNT),1	;SET THE TASK IN MOTION
	LD (IX),00H		;SET MOVE BYTE TO MEAN DONT MOVE
	RET
;
;*** END OF Q_BERT IN MOTION ROUTINE
;
;***THIS ROUTINE CHECKS TO SEE WHEN QBERT HAS REACHED THE END OF HIS FALL
QFALLING:
	LD A,(QCONTROL)		;GET MOVE BYTE OF QBERT CONTOL MATRIX
	CP 80H			;IS IT ARRIVED
	RET NZ			;IF NOT RETURN
	N.CLKRV TASK22		;IF ARRIVED THEN REMOVE THIS TASK
	LD A,1
	LD (CDECFM),A		;SET DEAD FLAG
	LD HL,QCONTROL
	LD A,120
	LD (IX+1),A
	LD (IX+3),A
	LD (IX+5),A
	LD A,22
	LD (IX+2),A
	LD (IX+4),A
	LD (IX+6),A
	RET
;***END OF ROUTINE TO CHECK FOR END OF QBERTS FALL
;
;*** THIS ROUTINE DETERMINES THE DESTINATION OF A CHARACTER BASED
;ON ITS CURRENT X,Y AND ITS DIRECTION AND PLACES THE DESTINATION BYTES
;IN THE CONTROL MATRIX
DETDEST:
	PUSH HL
	POP IX			;LD IX WITH THE CONTROL MATRIX ADDRESS
	LD A,(IX)		;GET DIRECTION BYTE FROM MATRIX
	AND 7FH			;CLEAR UPPER BIT
	CP 01H			;IS IT DIRECTION 1
	JP Z,DIR1		;IF SO MOVE CHARACTER UP AND LEFT
	CP 02H			;DIRECTION 2?
	JP Z,DIR2		;IF SO MOVE CHARACTER UP AND RIGHT
	CP 03H			; DIRECTION 3?
	JP Z,DIR3		;IF SO MOVE CHARACTER DOWN AND LEFT
	CP 04H			;DIRECTION 4?
	JP Z,DIR4		;IF SO MOVE CHARACTER DOWN AND RIGHT
	CP 06H			;DIRECTION 5
	JP Z,DIR5		;IF SO MOVE CHARACTER STRAIGHT LEFT
	CP 07H			;DIRECTION 6
	JP Z,DIR6		;IF SO MOVE CHARACTER STRAIGHT RIGHT
	RET
DIR1:
	LD A,(IX+5)		;A GETS THE CURRNET X
	SUB 10H			;SUBTRACT THE X OFFSET OF NEXT SQUARE
	LD (IX+3),A		;SAVE RESULT TO DESTINATION X
	LD A,(IX+6)		;GET CURRENT Y
	SUB 14H			;SUBTRACT Y OFFSET
	LD (IX+4),A		;SAVE DESTINATION Y
	JP ENDDEST
DIR2:
	LD A,(IX+5)		;A GETS CURRENT X
	ADD A,10H		;ADD X OFFSET OF NEXT SQUARE
	LD (IX+3),A		;SAVE DESTINATION X
	LD A,(IX+6)		;GET CURRENT Y
	SUB 14H			;SUBTRACT TO GET NEXT Y UP
	LD (IX+4),A		;SAVE DESTINATION Y
	JP ENDDEST
DIR3:
	LD A,(IX+5)		;A GETS CURRENT X
	SUB 10H			;SUBTRACT X OFFSET OF NEXT SQUARE
	LD (IX+3),A		;SAVE DESTINATION X
	LD A,(IX+6)		;GET CURRENT Y
	ADD A,14H		;ADD TO GET NEXT Y DOWN
	LD (IX+4),A		;SAVE DESTINATION Y
	JP ENDDEST
DIR4:
	LD A,(IX+5)		;A GETS CURRENT X
	ADD A,10H		;ADD X OFFSET OF NEXT SQUARE
	LD (IX+3),A		;SAVE DESTINATION X
	LD A,(IX+6)		;GET CURRENT Y
	ADD A,14H		;ADD TO GET NEXT Y DOWN
	LD (IX+4),A		;SAVE DESTINATION Y
	JP ENDDEST
DIR5:
	LD A,(IX+5)		;A GETS CURRENT X
	SUB 20H			;32 PIXELS TO MIDDLE OF NEXT CUBE LEFT
	LD (IX+3),A		;SAVE DESTINATION X IN MATRIX
	JP ENDD2
DIR6:
	LD A,(IX+5)		;A GETS CURRENT X
	ADD A,20H		;32 PIXELS TO MIDDLE OF NEXT CUBE RIGHT
	LD (IX+3),A		;SAVE DESTINATION X IN MATRIX
	JP ENDD2
;
ENDDEST:
	LD A,(IX+4)		;GET THE DESTINATION Y
	CP 95H			;THIS IS THE Y COORD OF SPRITE ON BOTTOM ROW
	JP C,ENDD2		;IF SPRITE STILL ABOVE BOTTOM ROW END NORMAL
	LD A,192		;ELSE SET NEW Y TO 192 TO MAKE CHARACTER FALL
	LD (IX+4),A		;FURTHER OFF THE BOTTOM OF THE PYRAMID
ENDD2:
	LD A,(IX+5)		;GET CURRENT X
	LD (IX+1),A		;REPLACE OIRIGIONAL X WITH CURRENT X
	LD A,(IX+6)		;GET CURRENT Y
	LD (IX+2),A		;REPLACE ORIGIONAL Y WITH CURRENT Y
	RET
;*** END OF ROUTINE TO CALCULATE THE DESTINATION OF CHARACTERS
;	JUMPING FROM CUBE TO CUBE
;***THIS ROUTINE WILL MOVE THE CHARACTER SPRITESIN ANY DIRECTION
;	BASED ON THE FIRST BYTE OF EACH CHARACTERS CONTROL MATRIX
MOVECHAR::
	PUSH HL	
	LD A,(HL)
	AND 7FH
	LD (CDIRECTION),A	;GET CHARACTER DIRECTION BYTE
	INC HL
	LD A,(HL)
	LD (ORIGX),A		;GET ORIGIONAL X FROM MATRIX
	INC HL
	LD A,(HL)
	LD (ORIGY),A		;GET ORIGIONAL Y FROM MATRIX
	INC HL
	LD A,(HL)
	LD (DESTX),A		;GET DESTINATION X FROM MATRIX
	INC HL
	LD A,(HL)
	LD (DESTY),A		;GET DESTINATION Y FROM MATRIX
	INC HL
	LD A,(HL)
	LD (CURX),A		;GET CURRENT X FROM MATRIX
	INC HL
	LD A,(HL)
	LD (CURY),A		;GET CURRENT Y FROM MATRIX
	INC HL
	LD A,(HL)
	LD (CSPRITE),A		;GET THE SPRITE NUMBER FROM MATRIX
	INC HL
	LD A,(HL)
	LD (PSHIFT),A		;GET BYTE WHICH CONTAINS THE SHIFT COUNT
				;FOR THE JUMPING ROUTINE
	LD A,(CDIRECTION)
	CP 01H			;IS IT DIRECTION 1
	JP Z,ULEFT		;IF SO MOVE CHARACTER UP AND LEFT
	CP 02H			;DIRECTION 2?
	JP Z,URIGHT		;IF SO MOVE CHARACTER UP AND RIGHT
	CP 03H			; DIRECTION 3?
	JP Z,DLEFT		;IF SO MOVE CHARACTER DOWN AND LEFT
	CP 04H			;DIRECTION 4?
	JP Z,DRIGHT		;IF SO MOVE CHARACTER DOWN AND RIGHT
	CP 05H			;DIRECTION 5?
	JP Z,SDOWN		;IF SO MOVE CHARACTER STRAIGHT DOWN
	CP 06H			;DIRECTION 6?
	JP Z,SLEFT		;IF SO MOVE CHARACTER STRAIGHT LEFT
	CP 07H			;DIRECTION 7
	JP Z,SRIGHT		;IF SO MOVE CHARACTER STRAIGHT RIGHT
	CP 08H			;DIRECTION 8?
	JP Z,DEATHFALL		;IF SO CHARACTER IS IN DEATH FALL
	POP HL
	RET
SDOWN:
	LD A,(CURY)		;A GETS THE CURRENT Y
	INC A			;MOVE DOWN 1 PIXEL
	LD (CURY),A		;SAVE THE NEW VALUE IN CURRENT Y VARIABLE
	LD C,A
	LD A,(DESTY)		;GET DESTINATION Y
	CP C			;COMPARE TO THE CURRENT Y
	JP NZ,FIXMATRIX		;IF NOT EQUAL GO MOVE SPRITE AND FIX MATRIX
	LD A,80H		;SET DIRECTION BYTE TO MEAN ACTIVE
				;BUT NOT MOVING
	LD (CDIRECTION),A	;SAVE THE VALUE IN THE DIRECTION VARIABLE
	JP FIXMATRIX		;GO MOVE SPRITE AND FIX MATRIX
DEATHFALL:
	XOR A			;CLEAR A
	LD (PSHIFT),A		;RESET THE PHASE SHIFT VALUE TO 0
	LD A,(CURY)		;A GETS THE CURRENT Y
	INC A			;MOVE DOWN 2 PIXELS
	INC A			;FALLS TWICE AS FAST AS NORMAL DOWN
	LD (CURY),A		;SAVE THE NEW VALUE IN CURRENT Y VARIABLE
	LD C,A
	LD A,(DESTY)		;GET DESTINATION Y
	CP C			;COMPARE TO THE CURRENT Y
	JP NC,DEATH2		;IF LESS EQUAL GO SEE IF SPRITE SHOULD BE SHOWN
	LD A,80H		;SET DIRECTION BYTE TO MEAN ACTIVE
				;BUT NOT MOVING
	LD (CDIRECTION),A	;SAVE THE VALUE IN THE DIRECTION VARIABLE
	JP FIXMATRIX		;GO MOVE SPRITE AND FIX MATRIX
DEATH2:
	LD A,(CURY)		;GET CURRENT Y
;	ADD A,8			;GET BOTTOM HALF CORNER OF SPRITE
	SRL A
	SRL A
	SRL A			;DIVIDE BY 8 TO GET PATTERN Y
	LD E,A			;E GETS THE Y COORDINATE
	LD A,(CURX)
	SRL A
	SRL A
	SRL A			;GET X AND DIVEIDE BY 8 TO GET PATTERN X
	LD C,A			;C GETS THE X COORDINATE
	CALL GETPAT		;GO GET PATTERN UNDER THE SPRITE
	CP 1			;IS IT LESS THAN 1
	JP C,FIXMATRIX		;IF SO GO MOVE SPRITE AND FIX MATRIX
	CP 69H			;IS IT GREATER THAN 69H
	JP NC,FIXMATRIX		;IF SO GO MOVE SPRITE AND FIX MATRIX
	LD A,0FFH
	LD (PSHIFT),A		;SET JUMP BYTE TO MEAN PASSING BEHIND PYRAMID
	JP FIXNOMOVE		;IF IN THE RANGE 1 TO 69H HE IS ON THE PYRAMID
				;SO GO FIX MATRIX BUT MOVE THE SPRITE OUT OF
				;OF THE WAY AND FIX THE MATRIX
ULEFT:
	LD A,(DESTY)		;A GETS DESTINATION X
	LD C,A			;MOVE THE DESTINATION TO X
	LD A,(CURY)		;A GETS THE CURRENT X
	CP C			;ARE THEY EQUAL?
	JP Z,MOVEL1		;IF SO DON'T MOVE ANY FURTHER
	DEC A			;ELSE MOVE 1 LEFT
	LD (CURY),A		;SAVE NEW X IN CURRENT X
	LD A,(PSHIFT)		;GET SHIFT COUNT
	CP 10H			;16 MOVES?
	JP Z,MOVEL1		;IF AT 8 GO FIX X COORDINATE
	INC A			;ADD 1 TO SHIFT COUNT
	LD (PSHIFT),A		;SAVE NEW SHIFT COUNT
	JP CHEND
MOVEL1:
	LD A,(DESTX)		;A GETS THE DESTINATION Y
	LD C,A
	LD A,(CURX)		;A GETS THE CURRENT Y
	CP C			;ARE THEY EQUAL?
	JP Z,CHEND		;IF EQUAL GO CHECK IF ARRIVED AT DESTINATION
	DEC A			;ELSE MOVE UP 1
	LD (CURX),A		;SAVE THE NEW Y LOCATION
	JP CHEND		;GO CHECK IF SPRITE IS AT DESTINATION
URIGHT:
	LD A,(DESTY)		;A GETS THE DESTINATION X
	LD C,A
	LD A,(CURY)		;A GETS THE CURRENT X
	CP C			; ARE THEY EQUAL
	JP Z,MOVEL2		;IF EQUAL DON'T MOVE FURTHER RIGHT
	DEC A			;MOVE RIGHT 1
	LD (CURY),A		;SAVE THE NEW X LOCATION
	LD A,(PSHIFT)		;GET SHIFT COUNT
	CP 10H			;16 MOVES?
	JP Z,MOVEL2		;IF AT 8 GO FIX X COORDINATE
	INC A			;ADD 1 TO SHIFT COUNT
	LD (PSHIFT),A		;SAVE NEW SHIFT COUNT
	JP CHEND
MOVEL2:
	LD A,(DESTX)		;A GETS THE DESTINATION Y
	LD C,A
	LD A,(CURX)		;A GETS THE CURRENT Y
	CP C			;ARE THEY EQUAL
	JP Z,CHEND		;IF EQUAL GO TEST FOR END DESTINATION
	INC A			;SUBTRACT 1 FROM Y
	LD (CURX),A		;SAVE NEW Y LOCATION
	JP CHEND		;GO TEST ARRIVAL AT DESTINATION
DLEFT:
	LD A,(DESTX)		;A GETS THE DESTINATION X
	LD C,A
	LD A,(CURX)		;A GETS THE CURRENT X
	CP C			;ARE THEY EQUAL
	JP Z,MOVEL3		;IF SO GO CHECK Y LOCATION
	DEC A			;MOVE LEFT 1
	LD (CURX),A		;SAVE NEW X LOCATION
	LD A,(PSHIFT)		;GET SHIFT VARIABLE
	CP 0CH			;GONE UP SIX PIX ALREADY
	JP Z,MOVEL3		;IF SO START TO BRING CHARACTER DOWN
	INC A			;INCREMENT PHASE SHIFT VARIABLE
	LD (PSHIFT),A		;SAVE NEW VALUE
	SRA A			;CHECK FOR ODD VALUE
	JP NC,CHEND
	LD A,(CURY)		
	DEC A
	LD (CURY),A
	JP CHEND
MOVEL3:
	LD A,(DESTY)		;A GETS THE DESTINATION Y
	LD C,A
	LD A,(CURY)		;A GETS THE CURRENT Y
	CP C			;ARE THEY EQUAL
	JP Z,CHEND		;IF THEY ARE GO CHECK ARRIVAL AT DESTINATIION
	INC A			;MOVE DOWN 1
	LD (CURY),A		;SAVE NEW Y LOCATION
	JP CHEND		;GO TEST ARRIVAL AT DESTINATION
DRIGHT:
	LD A,(DESTX)		;A GETS THE DESTINATION X
	LD C,A
	LD A,(CURX)		;A GETS THE CURRENT X
	CP C			;ARE THEY EQUAL?
	JP Z,MOVEL4		;IF SO GO CHECK Y LOCATON
	INC A			;MOVE RIGHT 1
	LD (CURX),A		;SAVE NEW X LOCATION
	LD A,(PSHIFT)		;GET SHIFT VARIABLE
	CP 0CH			;GONE UP SIX PIX ALREADY
	JP Z,MOVEL3		;IF SO START TO BRING CHARACTER DOWN
	INC A			;INCREMENT PHASE SHIFT VARIABLE
	LD (PSHIFT),A		;SAVE NEW VALUE
	SRA A			;ODD VALUE
	JP NC,CHEND
	LD A,(CURY)		
	DEC A
	LD (CURY),A
	JP CHEND
MOVEL4:
	LD A,(DESTY)		;A GETS THE DESTINATION Y
	LD C,A
	LD A,(CURY)		;A GETS THE CURRENT Y
	CP C			;ARE THEY EQUAL?
	JP Z,CHEND		;IF SO GO TEST ARRIVAL AT DESTINATION
	INC A			;MOVE DOWN 1
	LD (CURY),A		;SAVE NEW Y LOCATION
	JP CHEND		;GO TEST FOR ARRIVAL AT DESTINATION
CHEND:
	LD A,(CDIRECTION)
	CP 03			;DOWNLEFT
	JR NZ,CH2END
	LD A,(CHDOWN)
	INC A
	LD (CHDOWN),A		;INCREMENT DOWN MOVE CHECK
CH2END:
	LD A,(CDIRECTION)
	CP 01			;UPLEFT
	JR NZ,CH3END
	LD A,(CHUP)	
	INC A
	LD (CHUP),A
CH3END:
	LD A,(CURY)		;A GETS CURRENT Y
	LD C,A
	LD A,(DESTY)		;A GETS DESTINATION Y
	CP C			; ARE THEY EQUAL
	JP NZ,FIXMATRIX		;IF NOT DESTINATION HAS NOT BEEN REACHED
	LD A,(CURX)		;A GETS THE CURRENT X LOCATION
	LD C,A
	LD A,(DESTX)		;A GETS THE DESTINATION X
	CP C			;ARE THEY EQUAL?
	JP NZ,FIXMATRIX		;IF NOT DESTINATION HAS NOT BEEN REACHED
	LD A,80H		;THIS BYTE SIGNIFIES THE CHARACTER IS
				;ON THE BOARD BUT IS NOT MOVING
	LD (CDIRECTION),A	;SAVE THE DIRECTION IN THE DIRECTION VARIABLE
	LD A,00H
	LD (PSHIFT),A		;RESET PHASE SHIFT
	JP FIXMATRIX
SLEFT:
	LD A,(CURX)		;GET CURRENT X LOCATION
	DEC A			;SUBTRACT 1 FROM X LOCATION
	LD (CURX),A		;SAVE NEW CURRENT X LOCATION
	JP CHEND		;GO CHECK END CONDITION
SRIGHT:
	LD A,(CURX)		;GET THE CURRENT X VALUE
	INC A			;ADD 1 TO X LOCATION
	LD (CURX),A		;SAVE THE NEW X LOCATION
	LD C,A			;MOVE CURRENT X TO C REGISTER
	LD A,(DESTX)		;GET THE DESTINATION X VALUE
	CP C			;COMPARE DESTINATION TO CURRENT
	JP NZ,FIXMATRIX		;IF NOT EQUAL GO FIX MOVE MATRIX
	LD A,80H		;ELSE
	LD (CDIRECTION),A	;SET DIRECTION TO BE ON PYRAMID BUT
				;NOT MOVING
	JP FIXMATRIX		
FIXNOMOVE:			;CALLING THIS LABEL WILL GIVE THE EFFECT OF
				;HAVING THE SPRITE PASS BEHIND THE PYRAMID
	PCALL SPMOVE,(CSPRITE),0E0H,00H	;MOVE THE CHARACTER OUT OF THE WAY
	JP FIXM2
FIXMATRIX:
	PCALL SPMOVE,(CSPRITE),(CURY),(CURX)
FIXM2:
	POP IX
	LD A,(CDIRECTION)
	OR 80H			;RESET MOVE BIT
	LD (IX),A		;SAVE THE DIRECTION BACK IN THE MATRIX
	LD A,(ORIGX)
	LD (IX+1),A		;SAVE THE ORIGIONAL X
	LD A,(ORIGY)	
	LD (IX+2),A		;SAVE THE ORIGIONAL Y
	LD A,(DESTX)
	LD (IX+3),A		;SAVE THE DESTINATION X
	LD A,(DESTY)
	LD (IX+4),A		;SAVE THE DESTINATION Y
	LD A,(CURX)
	LD (IX+5),A		;SAVE THE CURRENT X
	LD A,(CURY)
	LD (IX+6),A		;SAVE THE CURRENT Y
	LD A,(CSPRITE)
	LD (IX+7),A		;SAVE SPRITE #
	LD A,(PSHIFT)
	LD (IX+8),A		;SAVE THE PHASE SHIFT
;
	LD A,(IX)
	CP 80H
	RET NZ
	LD A,(CHANLS)
	CP 0
	RET NZ		;IF SOMETHING PLAYING DON'T INTERUPT
	LD A,(CSPRITE)
	CP SASPRITE
	JP Z,DOSASO
	CP SLSPRITE
	JP Z,DOSASO
	CP QBSPRITE
	JP Z,DOQBSO
	CP CBSPRITE
	JP Z,DOCJSO
	PCALL SOUND2,CBSO1	;MAKE CHARACTER BOUNCE NOISE
	PCALL SOUND2,CBSO2
	PCALL SOUND2,C_OFF
	RET
DOSASO:
	PCALL SOUND2,SSSO1
	PCALL SOUND2,SSSO2
	PCALL SOUND2,C_OFF	;MAKE SAM/SLICK BOUNCE NOISE
	RET
DOQBSO:
	PCALL SOUND2,QJSO1
	PCALL SOUND2,QJSO2
	PCALL SOUND2,C_OFF
	RET
DOCJSO:
	PCALL SOUND2,CJSO1
	PCALL SOUND2,CJSO2
	PCALL SOUND2,C_OFF	;MAKE COILY JUMPING SOUND
	RET
;*** END OF CHARACTER MOVING ROUTINE
;
                END
	